{"version":3,"file":"index.js","sources":["../../src/background/tmdb/index.ts","../../src/background/letterboxd/index.ts","../../src/background/messaging/index.ts","../../src/background/index.ts"],"sourcesContent":["import { log } from \"../../shared/logger\";\nimport { STORAGE_KEYS } from \"../../shared/constants\";\nimport { buildTmdbCacheKey, normalizeTitle } from \"../../shared/normalize\";\nimport type { ExtractedTitleInfo, ResolveTitleMessage, TitleResolvedMessage } from \"../../shared/types\";\n\nconst TMDB_BASE_URL = \"https://api.themoviedb.org/3\";\nconst TMDB_CACHE_TTL_MS = 7 * 24 * 60 * 60 * 1000;\nconst TMDB_FEATURE_TTL_MS = 30 * 24 * 60 * 60 * 1000;\n\nexport type TmdbFeature = {\n  tmdbId: number;\n  mediaType: \"movie\" | \"tv\";\n  title?: string;\n  releaseYear?: number;\n  genres: string[];\n};\n\ntype TmdbCacheEntry = {\n  storedAt: number;\n  data: TitleResolvedMessage[\"payload\"];\n};\n\ntype TmdbCacheState = Record<string, TmdbCacheEntry>;\n\ntype TmdbFeatureCacheEntry = {\n  storedAt: number;\n  data: TmdbFeature;\n};\n\ntype TmdbFeatureCacheState = Record<string, TmdbFeatureCacheEntry>;\n\nconst getTmdbCache = async (): Promise<TmdbCacheState> => {\n  const data = await chrome.storage.local.get([STORAGE_KEYS.TMDB_CACHE]);\n  return (data[STORAGE_KEYS.TMDB_CACHE] as TmdbCacheState | undefined) ?? {};\n};\n\nconst setTmdbCache = async (cache: TmdbCacheState) => {\n  await chrome.storage.local.set({ [STORAGE_KEYS.TMDB_CACHE]: cache });\n};\n\nconst getFeatureCache = async (): Promise<TmdbFeatureCacheState> => {\n  const data = await chrome.storage.local.get([STORAGE_KEYS.TMDB_FEATURE_CACHE]);\n  return (data[STORAGE_KEYS.TMDB_FEATURE_CACHE] as TmdbFeatureCacheState | undefined) ?? {};\n};\n\nconst setFeatureCache = async (cache: TmdbFeatureCacheState) => {\n  await chrome.storage.local.set({ [STORAGE_KEYS.TMDB_FEATURE_CACHE]: cache });\n};\n\nexport const getTmdbApiKey = async (): Promise<string | null> => {\n  const data = await chrome.storage.local.get([STORAGE_KEYS.TMDB_API_KEY]);\n  const key = data[STORAGE_KEYS.TMDB_API_KEY] as string | undefined;\n  return key?.trim() ? key.trim() : null;\n};\n\ntype TmdbSearchResult = {\n  id?: number;\n  title?: string;\n  name?: string;\n  release_date?: string;\n  first_air_date?: string;\n  media_type?: string;\n};\n\nconst getTitleSimilarity = (a: string, b: string) => {\n  if (!a || !b) return 0;\n  if (a === b) return 1;\n  if (a.includes(b) || b.includes(a)) return 0.8;\n  const aTokens = new Set(a.split(\" \").filter(Boolean));\n  const bTokens = new Set(b.split(\" \").filter(Boolean));\n  if (!aTokens.size || !bTokens.size) return 0;\n  let overlap = 0;\n  aTokens.forEach((token) => {\n    if (bTokens.has(token)) overlap += 1;\n  });\n  const union = new Set([...aTokens, ...bTokens]).size;\n  return union ? overlap / union : 0;\n};\n\nconst scoreCandidate = (\n  info: ExtractedTitleInfo,\n  candidate: TmdbSearchResult,\n  mediaType: \"movie\" | \"tv\"\n) => {\n  const candidateTitle = candidate.title ?? candidate.name ?? \"\";\n  const normalizedCandidate = normalizeTitle(candidateTitle);\n  const normalizedQuery = info.normalizedTitle || normalizeTitle(info.rawTitle);\n  const similarity = getTitleSimilarity(normalizedQuery, normalizedCandidate);\n  let score = similarity * 100;\n\n  const releaseDate = candidate.release_date ?? candidate.first_air_date;\n  const candidateYear = releaseDate ? Number(releaseDate.slice(0, 4)) : undefined;\n  if (info.year && candidateYear) {\n    const diff = Math.abs(info.year - candidateYear);\n    if (diff === 0) score += 20;\n    else if (diff === 1) score += 8;\n    else score -= Math.min(20, diff * 4);\n  }\n\n  if (info.isSeries === true) score += mediaType === \"tv\" ? 10 : -10;\n  if (info.isSeries === false) score += mediaType === \"movie\" ? 10 : -10;\n\n  return { score, candidateTitle, candidateYear };\n};\n\nconst pickBestMatch = (\n  info: ExtractedTitleInfo,\n  results: TmdbSearchResult[],\n  mediaType: \"movie\" | \"tv\"\n) => {\n  if (!results.length) return null;\n  let best: { result: TmdbSearchResult; score: number } | null = null;\n  results.forEach((result) => {\n    if (!result.id) return;\n    const { score } = scoreCandidate(info, result, mediaType);\n    if (!best || score > best.score) {\n      best = { result, score };\n    }\n  });\n  if (!best || best.score < 50) return null;\n  return best.result;\n};\n\nconst fetchJson = async (url: string) => {\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(`TMDb request failed: ${response.status}`);\n  }\n  return response.json();\n};\n\ntype ResolvedTitle = TitleResolvedMessage[\"payload\"] & { tmdbGenres?: string[] };\n\ntype TmdbResolveInput = ExtractedTitleInfo | ResolveTitleMessage[\"payload\"];\n\nconst coerceExtractedInfo = (payload: TmdbResolveInput): ExtractedTitleInfo => {\n  if (\"rawTitle\" in payload) return payload;\n  const rawTitle = payload.titleText ?? \"Unknown title\";\n  return {\n    rawTitle,\n    normalizedTitle: normalizeTitle(rawTitle),\n    year: payload.year ?? null,\n    isSeries: undefined,\n    netflixId: payload.netflixTitleId ?? null,\n    href: payload.href ?? null\n  };\n};\n\nconst pickBestFromMulti = (info: ExtractedTitleInfo, results: TmdbSearchResult[]) => {\n  let best: { result: TmdbSearchResult; mediaType: \"movie\" | \"tv\"; score: number } | null = null;\n  results.forEach((result) => {\n    const mediaType = result.media_type === \"tv\" ? \"tv\" : result.media_type === \"movie\" ? \"movie\" : null;\n    if (!mediaType || !result.id) return;\n    const { score } = scoreCandidate(info, result, mediaType);\n    if (!best || score > best.score) best = { result, mediaType, score };\n  });\n  if (!best || best.score < 50) return null;\n  return best;\n};\n\nexport const resolveTitleWithTmdb = async (\n  payload: TmdbResolveInput\n): Promise<ResolvedTitle> => {\n  const apiKey = await getTmdbApiKey();\n  const info = coerceExtractedInfo(payload);\n  if (!apiKey || !info.rawTitle) {\n    log(\"TMDb resolve skipped (missing api key or title)\", { hasKey: !!apiKey, info });\n    return { title: info.rawTitle ?? \"Unknown title\" };\n  }\n\n  const cacheKey = buildTmdbCacheKey(info.rawTitle, info.year ?? undefined);\n  const cache = await getTmdbCache();\n  const cached = cache[cacheKey];\n  if (cached && Date.now() - cached.storedAt < TMDB_CACHE_TTL_MS) {\n    log(\"TMDb cache hit\", { cacheKey });\n    const mediaType = cached.data.tmdbMediaType ?? \"movie\";\n    if (cached.data.tmdbId) {\n      const features = await getTmdbFeatures(apiKey, cached.data.tmdbId, mediaType);\n      return {\n        ...cached.data,\n        tmdbGenres: features?.genres ?? []\n      };\n    }\n    return cached.data;\n  }\n\n  const query = info.rawTitle;\n  const year = info.year ?? undefined;\n  const mediaGuess = info.isSeries === true ? \"tv\" : info.isSeries === false ? \"movie\" : \"multi\";\n  log(\"TMDB_SEARCH_REQUEST\", { query, year, mediaType: mediaGuess });\n\n  let match: TmdbSearchResult | null = null;\n  let mediaType: \"movie\" | \"tv\" | null = null;\n\n  if (mediaGuess === \"tv\") {\n    const params = new URLSearchParams({\n      api_key: apiKey,\n      query,\n      ...(year ? { first_air_date_year: String(year) } : {})\n    });\n    const searchUrl = `${TMDB_BASE_URL}/search/tv?${params.toString()}`;\n    const searchData = await fetchJson(searchUrl);\n    match = pickBestMatch(info, searchData?.results ?? [], \"tv\");\n    mediaType = match ? \"tv\" : null;\n  } else if (mediaGuess === \"movie\") {\n    const params = new URLSearchParams({\n      api_key: apiKey,\n      query,\n      ...(year ? { year: String(year) } : {})\n    });\n    const searchUrl = `${TMDB_BASE_URL}/search/movie?${params.toString()}`;\n    const searchData = await fetchJson(searchUrl);\n    match = pickBestMatch(info, searchData?.results ?? [], \"movie\");\n    mediaType = match ? \"movie\" : null;\n  }\n\n  if (!match) {\n    const params = new URLSearchParams({\n      api_key: apiKey,\n      query\n    });\n    const searchUrl = `${TMDB_BASE_URL}/search/multi?${params.toString()}`;\n    const searchData = await fetchJson(searchUrl);\n    const filtered = (searchData?.results ?? []).filter(\n      (item: TmdbSearchResult) => item.media_type === \"movie\" || item.media_type === \"tv\"\n    );\n    const best = pickBestFromMulti(info, filtered);\n    if (best) {\n      match = best.result;\n      mediaType = best.mediaType;\n    }\n  }\n\n  if (!match?.id || !mediaType) {\n    log(\"TMDB_NO_MATCH\", { titleText: info.rawTitle, year, mediaType: mediaGuess });\n    return { title: info.rawTitle };\n  }\n\n  const detailsUrl = `${TMDB_BASE_URL}/${mediaType}/${match.id}?api_key=${apiKey}`;\n  log(\"TMDB_SEARCH_CHOSEN\", {\n    title: match.title ?? match.name,\n    year: match.release_date ?? match.first_air_date,\n    mediaType\n  });\n  const details = await fetchJson(detailsUrl);\n\n  const releaseDate =\n    mediaType === \"tv\"\n      ? details.first_air_date ?? match.first_air_date\n      : details.release_date ?? match.release_date;\n  const releaseYear = releaseDate ? Number(releaseDate.slice(0, 4)) : undefined;\n\n  const resolved: ResolvedTitle = {\n    title: (details.title ?? details.name) ?? info.rawTitle ?? \"Unknown title\",\n    tmdbId: details.id,\n    tmdbVoteAverage: details.vote_average,\n    tmdbVoteCount: details.vote_count,\n    posterPath: details.poster_path ?? undefined,\n    releaseYear: Number.isNaN(releaseYear) ? undefined : releaseYear,\n    tmdbMediaType: mediaType,\n    tmdbGenres: Array.isArray(details.genres)\n      ? details.genres.map((genre: { name: string }) => genre.name.toLowerCase())\n      : []\n  };\n\n  const { tmdbGenres, ...cachePayload } = resolved;\n  void tmdbGenres;\n  cache[cacheKey] = { storedAt: Date.now(), data: cachePayload };\n  await setTmdbCache(cache);\n  log(\"TMDb cached result\", { cacheKey, tmdbId: resolved.tmdbId });\n\n  return resolved;\n};\n\nexport const getTmdbFeatures = async (\n  apiKey: string,\n  tmdbId: number,\n  mediaType: \"movie\" | \"tv\"\n): Promise<TmdbFeature | null> => {\n  const cache = await getFeatureCache();\n  const cacheKey = `${mediaType}:${tmdbId}`;\n  const cached = cache[cacheKey];\n  if (cached && Date.now() - cached.storedAt < TMDB_FEATURE_TTL_MS) {\n    return cached.data;\n  }\n\n  const detailsUrl = `${TMDB_BASE_URL}/${mediaType}/${tmdbId}?api_key=${apiKey}`;\n  const details = await fetchJson(detailsUrl);\n  const releaseDate = mediaType === \"tv\" ? details.first_air_date : details.release_date;\n  const releaseYear = releaseDate ? Number(releaseDate.slice(0, 4)) : undefined;\n  const features: TmdbFeature = {\n    tmdbId,\n    mediaType,\n    title: details.title ?? details.name,\n    releaseYear: Number.isNaN(releaseYear) ? undefined : releaseYear,\n    genres: Array.isArray(details.genres)\n      ? details.genres.map((genre: { name: string }) => genre.name.toLowerCase())\n      : []\n  };\n\n  cache[cacheKey] = { storedAt: Date.now(), data: features };\n  await setFeatureCache(cache);\n  return features;\n};\n\nexport const searchTmdbId = async (\n  apiKey: string,\n  titleText: string,\n  year?: number,\n  cache?: TmdbCacheState\n): Promise<{ tmdbId: number; title?: string; releaseYear?: number; mediaType: \"movie\" } | null> => {\n  if (cache) {\n    const key = buildTmdbCacheKey(titleText, year);\n    const cached = cache[key];\n    if (cached?.data?.tmdbId) {\n      return {\n        tmdbId: cached.data.tmdbId,\n        title: cached.data.title,\n        releaseYear: cached.data.releaseYear,\n        mediaType: \"movie\"\n      };\n    }\n  }\n  const params = new URLSearchParams({\n    api_key: apiKey,\n    query: titleText\n  });\n  if (year) params.set(\"year\", String(year));\n  const searchUrl = `${TMDB_BASE_URL}/search/movie?${params.toString()}`;\n  const searchData = await fetchJson(searchUrl);\n  const info: ExtractedTitleInfo = {\n    rawTitle: titleText,\n    normalizedTitle: normalizeTitle(titleText),\n    year: year ?? null,\n    isSeries: false,\n    netflixId: null,\n    href: null\n  };\n  const match = pickBestMatch(info, searchData?.results ?? [], \"movie\");\n  if (!match?.id) return null;\n  const releaseYear = match.release_date ? Number(match.release_date.slice(0, 4)) : undefined;\n  return {\n    tmdbId: match.id,\n    title: match.title,\n    releaseYear: Number.isNaN(releaseYear) ? undefined : releaseYear,\n    mediaType: \"movie\"\n  };\n};\n\nexport const getTmdbCacheSnapshot = async (): Promise<TmdbCacheState> => getTmdbCache();\n","import { log } from \"../../shared/logger\";\nimport { STORAGE_KEYS } from \"../../shared/constants\";\nimport {\n  buildLegacyLetterboxdKey,\n  buildLetterboxdKey,\n  parseLetterboxdKey\n} from \"../../shared/normalize\";\nimport type { ExtractedTitleInfo, LetterboxdIndex, ResolveTitleMessage } from \"../../shared/types\";\nimport { getLetterboxdIndex as loadLetterboxdIndex } from \"../../shared/storage\";\nimport {\n  getTmdbApiKey,\n  getTmdbFeatures,\n  getTmdbCacheSnapshot,\n  searchTmdbId\n} from \"../tmdb\";\n\nconst PROFILE_TTL_MS = 24 * 60 * 60 * 1000;\n\ntype MatchProfile = {\n  storedAt: number;\n  lastImportAt?: string;\n  meanRating: number;\n  genreStats: Record<string, { avg: number; count: number; strength: number }>;\n  decadeStats: Record<string, { avg: number; count: number; strength: number }>;\n};\n\nconst getLetterboxdIndex = async (): Promise<LetterboxdIndex | null> => {\n  return loadLetterboxdIndex();\n};\n\nconst getLetterboxdStats = async (): Promise<{ importedAt?: string } | null> => {\n  const data = await chrome.storage.local.get([STORAGE_KEYS.LETTERBOXD_STATS]);\n  return (data[STORAGE_KEYS.LETTERBOXD_STATS] as { importedAt?: string } | undefined) ?? null;\n};\n\nconst getMatchProfileCache = async (): Promise<MatchProfile | null> => {\n  const data = await chrome.storage.local.get([STORAGE_KEYS.MATCH_PROFILE]);\n  return (data[STORAGE_KEYS.MATCH_PROFILE] as MatchProfile | undefined) ?? null;\n};\n\nconst setMatchProfileCache = async (profile: MatchProfile) => {\n  await chrome.storage.local.set({ [STORAGE_KEYS.MATCH_PROFILE]: profile });\n};\n\nexport const resolveLetterboxdEntry = async (\n  payload: ResolveTitleMessage[\"payload\"] | ExtractedTitleInfo,\n  resolvedTitle?: string,\n  resolvedYear?: number\n) => {\n  const index = await getLetterboxdIndex();\n  if (!index) {\n    log(\"LB_INDEX_LOADED\", { found: false });\n    return {};\n  }\n  log(\"LB_INDEX_LOADED\", {\n    found: true,\n    updatedAt: index.updatedAt,\n    ratingsCount: Object.keys(index.ratingsByKey).length,\n    watchlistCount: Object.keys(index.watchlistKeys).length\n  });\n  const payloadTitle = \"rawTitle\" in payload ? payload.rawTitle : payload.titleText;\n  const payloadYear = \"rawTitle\" in payload ? payload.year ?? undefined : payload.year;\n\n  const keys = [\n    buildLetterboxdKey(payloadTitle, payloadYear),\n    buildLetterboxdKey(resolvedTitle, resolvedYear),\n    buildLetterboxdKey(payloadTitle, undefined),\n    buildLetterboxdKey(resolvedTitle, undefined)\n  ].filter((key) => key);\n  const legacyKeys = [\n    buildLegacyLetterboxdKey(payloadTitle, payloadYear),\n    buildLegacyLetterboxdKey(resolvedTitle, resolvedYear),\n    buildLegacyLetterboxdKey(payloadTitle, undefined),\n    buildLegacyLetterboxdKey(resolvedTitle, undefined)\n  ].filter((key) => key);\n  const attemptedKeys = Array.from(new Set([...keys, ...legacyKeys]));\n  log(\"LB_MATCH_KEYS\", { attemptedKeys });\n\n  for (const key of attemptedKeys) {\n    if (index.watchlistKeys[key] || index.ratingsByKey[key] !== undefined) {\n      log(\"LB_MATCH_FOUND\", { key });\n      return {\n        inWatchlist: index.watchlistKeys[key] === true,\n        userRating: index.ratingsByKey[key]\n      };\n    }\n  }\n\n  log(\"LB_MATCH_NOT_FOUND\", { attemptedKeys, title: resolvedTitle ?? payloadTitle });\n  return {};\n};\n\nexport const buildMatchProfile = async (): Promise<MatchProfile | null> => {\n  const apiKey = await getTmdbApiKey();\n  if (!apiKey) return null;\n\n  const stats = await getLetterboxdStats();\n  const cached = await getMatchProfileCache();\n  if (\n    cached &&\n    Date.now() - cached.storedAt < PROFILE_TTL_MS &&\n    cached.lastImportAt &&\n    stats?.importedAt &&\n    cached.lastImportAt === stats.importedAt\n  ) {\n    return cached;\n  }\n\n  const index = await getLetterboxdIndex();\n  if (!index) return null;\n  const tmdbCache = await getTmdbCacheSnapshot();\n  const entries = Object.entries(index.ratingsByKey);\n  if (!entries.length) return null;\n\n  let ratingSum = 0;\n  let ratingCount = 0;\n  const genreTotals: Record<string, { sum: number; count: number }> = {};\n  const decadeTotals: Record<string, { sum: number; count: number }> = {};\n\n  const maxEntries = 300;\n  for (const [key, rating] of entries.slice(0, maxEntries)) {\n    ratingSum += rating;\n    ratingCount += 1;\n\n    const { title, year } = parseLetterboxdKey(key);\n    if (!title) continue;\n\n    const searchResult = await searchTmdbId(apiKey, title, year, tmdbCache);\n    if (!searchResult) continue;\n\n    const features = await getTmdbFeatures(apiKey, searchResult.tmdbId, searchResult.mediaType);\n    if (!features) continue;\n\n    const releaseYear = features.releaseYear ?? searchResult.releaseYear ?? year;\n    const decade = releaseYear ? `${Math.floor(releaseYear / 10) * 10}s` : undefined;\n\n    features.genres.forEach((genre) => {\n      if (!genreTotals[genre]) genreTotals[genre] = { sum: 0, count: 0 };\n      genreTotals[genre].sum += rating;\n      genreTotals[genre].count += 1;\n    });\n\n    if (decade) {\n      if (!decadeTotals[decade]) decadeTotals[decade] = { sum: 0, count: 0 };\n      decadeTotals[decade].sum += rating;\n      decadeTotals[decade].count += 1;\n    }\n  }\n\n  const meanRating = ratingCount ? ratingSum / ratingCount : 0;\n  const genreStats: MatchProfile[\"genreStats\"] = {};\n  const decadeStats: MatchProfile[\"decadeStats\"] = {};\n\n  Object.entries(genreTotals).forEach(([genre, { sum, count }]) => {\n    const avg = sum / count;\n    genreStats[genre] = {\n      avg,\n      count,\n      strength: avg - meanRating\n    };\n  });\n\n  Object.entries(decadeTotals).forEach(([decade, { sum, count }]) => {\n    const avg = sum / count;\n    decadeStats[decade] = {\n      avg,\n      count,\n      strength: avg - meanRating\n    };\n  });\n\n  const profile: MatchProfile = {\n    storedAt: Date.now(),\n    lastImportAt: stats?.importedAt,\n    meanRating,\n    genreStats,\n    decadeStats\n  };\n\n  await setMatchProfileCache(profile);\n  return profile;\n};\n\nexport const computeMatchScore = (\n  profile: MatchProfile | null,\n  candidateGenres: string[]\n): { matchPercent: number | null; becauseYouLike: string[] } => {\n  if (!profile || !candidateGenres.length) return { matchPercent: null, becauseYouLike: [] };\n\n  let weightedSum = 0;\n  let totalWeight = 0;\n  const positives: { genre: string; strength: number }[] = [];\n\n  candidateGenres.forEach((genre) => {\n    const normalized = genre.toLowerCase();\n    const stats = profile.genreStats[normalized];\n    if (!stats) return;\n    const confidence = Math.min(1, stats.count / 5);\n    const strength = stats.strength;\n    weightedSum += strength * confidence;\n    totalWeight += confidence;\n    if (strength > 0) {\n      positives.push({ genre: normalized, strength });\n    }\n  });\n\n  if (totalWeight === 0) return { matchPercent: null, becauseYouLike: [] };\n  const normalized = weightedSum / totalWeight;\n  const score = Math.round(Math.max(0, Math.min(100, 50 + normalized * 20)));\n\n  const topGenres = positives\n    .sort((a, b) => b.strength - a.strength)\n    .slice(0, 2)\n    .map((entry) => entry.genre.replace(/\\b\\w/g, (letter) => letter.toUpperCase()));\n\n  return { matchPercent: score, becauseYouLike: topGenres };\n};\n","import { log } from \"../../shared/logger\";\nimport { STORAGE_KEYS } from \"../../shared/constants\";\nimport type {\n  ExtensionRuntimeMessage,\n  LetterboxdIndexUpdatedAckMessage,\n  LetterboxdIndexUpdatedMessage,\n  OverlayDataResolvedMessage,\n  ResolveOverlayDataMessage,\n  ResolveTitleMessage,\n  TitleResolvedMessage\n} from \"../../shared/types\";\nimport { resolveTitleWithTmdb } from \"../tmdb\";\nimport { buildMatchProfile, computeMatchScore, resolveLetterboxdEntry } from \"../letterboxd\";\n\nexport const registerMessageHandlers = () => {\n  chrome.runtime.onMessage.addListener(\n    (message: ExtensionRuntimeMessage, sender, sendResponse) => {\n      log(\"Background received message\", { message, sender });\n\n      if (message.type === \"LB_INDEX_UPDATED\") {\n        const updated = message as LetterboxdIndexUpdatedMessage;\n        void updated;\n        void (async () => {\n          await chrome.storage.local.remove([STORAGE_KEYS.MATCH_PROFILE]);\n          log(\"LB_INDEX_UPDATED\");\n          const ack: LetterboxdIndexUpdatedAckMessage = {\n            type: \"LB_INDEX_UPDATED_ACK\",\n            payload: { updatedAt: Date.now() }\n          };\n          try {\n            chrome.runtime.sendMessage(ack).catch(() => undefined);\n          } catch {\n            // noop\n          }\n          sendResponse(ack);\n        })();\n        return true;\n      }\n\n      if (message.type === \"RESOLVE_OVERLAY_DATA\") {\n        const { requestId, payload } = message as ResolveOverlayDataMessage;\n\n        void (async () => {\n          try {\n            const resolved = await resolveTitleWithTmdb(payload);\n            const lbData = await resolveLetterboxdEntry(\n              payload,\n              resolved.title,\n              resolved.releaseYear ?? payload.year ?? undefined\n            );\n            const profile = await buildMatchProfile();\n            const matchData = computeMatchScore(profile, resolved.tmdbGenres ?? []);\n\n            const response: OverlayDataResolvedMessage = {\n              type: \"OVERLAY_DATA_RESOLVED\",\n              requestId,\n              payload: {\n                title: resolved.title ?? payload.rawTitle ?? \"Unknown title\",\n                year: resolved.releaseYear ?? payload.year ?? null,\n                tmdb: {\n                  id: resolved.tmdbId ?? null,\n                  voteAverage: resolved.tmdbVoteAverage ?? null,\n                  voteCount: resolved.tmdbVoteCount ?? null\n                },\n                letterboxd: {\n                  inWatchlist: lbData.inWatchlist ?? false,\n                  userRating: lbData.userRating ?? null,\n                  matchPercent: matchData.matchPercent ?? null,\n                  becauseYouLike: matchData.becauseYouLike ?? []\n                }\n              }\n            };\n            sendResponse(response);\n          } catch (error) {\n            log(\"Overlay resolve failed\", { error });\n            const response: OverlayDataResolvedMessage = {\n              type: \"OVERLAY_DATA_RESOLVED\",\n              requestId,\n              payload: {\n                title: payload.rawTitle ?? \"Unknown title\",\n                year: payload.year ?? null,\n                tmdb: {\n                  id: null,\n                  voteAverage: null,\n                  voteCount: null\n                },\n                letterboxd: {\n                  inWatchlist: false,\n                  userRating: null,\n                  matchPercent: null,\n                  becauseYouLike: []\n                }\n              }\n            };\n            sendResponse(response);\n          }\n        })();\n\n        return true;\n      }\n\n      if (message.type === \"RESOLVE_TITLE\") {\n        const { requestId, payload } = message as ResolveTitleMessage;\n\n        void (async () => {\n          try {\n            const resolved = await resolveTitleWithTmdb(payload);\n            const lbData = await resolveLetterboxdEntry(\n              payload,\n              resolved.title,\n              resolved.releaseYear ?? payload.year\n            );\n            const profile = await buildMatchProfile();\n            const matchData = computeMatchScore(profile, resolved.tmdbGenres ?? []);\n            const { tmdbGenres, ...resolvedPayload } = resolved;\n            void tmdbGenres;\n            const response: TitleResolvedMessage = {\n              type: \"TITLE_RESOLVED\",\n              requestId,\n              payload: {\n                ...resolvedPayload,\n                ...lbData,\n                ...matchData\n              }\n            };\n            sendResponse(response);\n          } catch (error) {\n            log(\"TMDb resolve failed\", { error });\n            const lbData = await resolveLetterboxdEntry(\n              payload,\n              payload.titleText ?? \"Unknown title\",\n              payload.year\n            );\n            sendResponse({\n              type: \"TITLE_RESOLVED\",\n              requestId,\n              payload: {\n                title: payload.titleText ?? \"Unknown title\",\n                ...lbData\n              }\n            } satisfies TitleResolvedMessage);\n          }\n        })();\n\n        return true;\n      }\n\n      return false;\n    }\n  );\n};\n","import { log } from \"../shared/logger\";\nimport { registerMessageHandlers } from \"./messaging\";\n\nchrome.runtime.onInstalled.addListener((details) => {\n  log(\"Extension installed\", details);\n});\n\nregisterMessageHandlers();\n"],"names":["TMDB_BASE_URL","TMDB_CACHE_TTL_MS","TMDB_FEATURE_TTL_MS","getTmdbCache","STORAGE_KEYS","setTmdbCache","cache","getFeatureCache","setFeatureCache","getTmdbApiKey","key","getTitleSimilarity","a","b","aTokens","bTokens","overlap","token","union","scoreCandidate","info","candidate","mediaType","candidateTitle","normalizedCandidate","normalizeTitle","normalizedQuery","score","releaseDate","candidateYear","diff","pickBestMatch","results","best","result","fetchJson","url","response","coerceExtractedInfo","payload","rawTitle","pickBestFromMulti","resolveTitleWithTmdb","apiKey","log","cacheKey","buildTmdbCacheKey","cached","features","getTmdbFeatures","query","year","mediaGuess","match","params","searchUrl","searchData","filtered","item","detailsUrl","details","releaseYear","resolved","genre","tmdbGenres","cachePayload","tmdbId","searchTmdbId","titleText","_a","getTmdbCacheSnapshot","PROFILE_TTL_MS","getLetterboxdIndex","loadLetterboxdIndex","getLetterboxdStats","getMatchProfileCache","setMatchProfileCache","profile","resolveLetterboxdEntry","resolvedTitle","resolvedYear","index","payloadTitle","payloadYear","keys","buildLetterboxdKey","legacyKeys","buildLegacyLetterboxdKey","attemptedKeys","buildMatchProfile","stats","tmdbCache","entries","ratingSum","ratingCount","genreTotals","decadeTotals","maxEntries","rating","title","parseLetterboxdKey","searchResult","decade","meanRating","genreStats","decadeStats","sum","count","avg","computeMatchScore","candidateGenres","weightedSum","totalWeight","positives","normalized","confidence","strength","topGenres","entry","letter","registerMessageHandlers","message","sender","sendResponse","ack","requestId","lbData","matchData","error","resolvedPayload"],"mappings":"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"}