{"version":3,"file":"index.js","sources":["../../src/background/tmdb/index.ts","../../src/background/letterboxd/index.ts","../../src/background/messaging/index.ts","../../src/background/index.ts"],"sourcesContent":["import { log } from \"../../shared/logger\";\nimport { STORAGE_KEYS } from \"../../shared/constants\";\nimport { buildTmdbCacheKey, normalizeTitle } from \"../../shared/normalize\";\nimport type { ResolveTitleMessage, TitleResolvedMessage } from \"../../shared/types\";\n\nconst TMDB_BASE_URL = \"https://api.themoviedb.org/3\";\nconst TMDB_CACHE_TTL_MS = 7 * 24 * 60 * 60 * 1000;\nconst TMDB_FEATURE_TTL_MS = 30 * 24 * 60 * 60 * 1000;\n\nexport type TmdbFeature = {\n  tmdbId: number;\n  mediaType: \"movie\" | \"tv\";\n  title?: string;\n  releaseYear?: number;\n  genres: string[];\n};\n\ntype TmdbCacheEntry = {\n  storedAt: number;\n  data: TitleResolvedMessage[\"payload\"];\n};\n\ntype TmdbCacheState = Record<string, TmdbCacheEntry>;\n\ntype TmdbFeatureCacheEntry = {\n  storedAt: number;\n  data: TmdbFeature;\n};\n\ntype TmdbFeatureCacheState = Record<string, TmdbFeatureCacheEntry>;\n\nconst getTmdbCache = async (): Promise<TmdbCacheState> => {\n  const data = await chrome.storage.local.get([STORAGE_KEYS.TMDB_CACHE]);\n  return (data[STORAGE_KEYS.TMDB_CACHE] as TmdbCacheState | undefined) ?? {};\n};\n\nconst setTmdbCache = async (cache: TmdbCacheState) => {\n  await chrome.storage.local.set({ [STORAGE_KEYS.TMDB_CACHE]: cache });\n};\n\nconst getFeatureCache = async (): Promise<TmdbFeatureCacheState> => {\n  const data = await chrome.storage.local.get([STORAGE_KEYS.TMDB_FEATURE_CACHE]);\n  return (data[STORAGE_KEYS.TMDB_FEATURE_CACHE] as TmdbFeatureCacheState | undefined) ?? {};\n};\n\nconst setFeatureCache = async (cache: TmdbFeatureCacheState) => {\n  await chrome.storage.local.set({ [STORAGE_KEYS.TMDB_FEATURE_CACHE]: cache });\n};\n\nexport const getTmdbApiKey = async (): Promise<string | null> => {\n  const data = await chrome.storage.local.get([STORAGE_KEYS.TMDB_API_KEY]);\n  const key = data[STORAGE_KEYS.TMDB_API_KEY] as string | undefined;\n  return key?.trim() ? key.trim() : null;\n};\n\ntype TmdbSearchResult = {\n  id?: number;\n  title?: string;\n  name?: string;\n  release_date?: string;\n  first_air_date?: string;\n  media_type?: string;\n};\n\nconst pickBestMatch = (\n  results: TmdbSearchResult[],\n  titleText?: string,\n  year?: number\n) => {\n  if (!results.length) return null;\n  const normalized = normalizeTitle(titleText);\n\n  const exactTitleAndYear = results.find((item) => {\n    const resultTitle = normalizeTitle(item.title ?? item.name);\n    const releaseDate = item.release_date ?? item.first_air_date;\n    const releaseYear = releaseDate ? Number(releaseDate.slice(0, 4)) : undefined;\n    return resultTitle === normalized && year && releaseYear === year;\n  });\n  if (exactTitleAndYear) return exactTitleAndYear;\n\n  const exactTitle = results.find((item) => normalizeTitle(item.title ?? item.name) === normalized);\n  if (exactTitle) return exactTitle;\n\n  return results[0];\n};\n\nconst fetchJson = async (url: string) => {\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(`TMDb request failed: ${response.status}`);\n  }\n  return response.json();\n};\n\ntype ResolvedTitle = TitleResolvedMessage[\"payload\"] & { tmdbGenres?: string[] };\n\nexport const resolveTitleWithTmdb = async (\n  payload: ResolveTitleMessage[\"payload\"]\n): Promise<ResolvedTitle> => {\n  const apiKey = await getTmdbApiKey();\n  if (!apiKey || !payload.titleText) {\n    log(\"TMDb resolve skipped (missing api key or title)\", { hasKey: !!apiKey, payload });\n    return { title: payload.titleText ?? \"Unknown title\" };\n  }\n\n  const cacheKey = buildTmdbCacheKey(payload.titleText, payload.year);\n  const cache = await getTmdbCache();\n  const cached = cache[cacheKey];\n  if (cached && Date.now() - cached.storedAt < TMDB_CACHE_TTL_MS) {\n    log(\"TMDb cache hit\", { cacheKey });\n    const mediaType = cached.data.tmdbMediaType ?? \"movie\";\n    if (cached.data.tmdbId) {\n      const features = await getTmdbFeatures(apiKey, cached.data.tmdbId, mediaType);\n      return {\n        ...cached.data,\n        tmdbGenres: features?.genres ?? []\n      };\n    }\n    return cached.data;\n  }\n\n  const params = new URLSearchParams({\n    api_key: apiKey,\n    query: payload.titleText\n  });\n\n  const searchUrl = `${TMDB_BASE_URL}/search/multi?${params.toString()}`;\n  log(\"TMDb search\", { searchUrl });\n  const searchData = await fetchJson(searchUrl);\n  const filtered = (searchData?.results ?? []).filter(\n    (item: TmdbSearchResult) => item.media_type === \"movie\" || item.media_type === \"tv\"\n  );\n  const match = pickBestMatch(filtered, payload.titleText, payload.year);\n\n  if (!match?.id) {\n    log(\"TMDb no match\", { titleText: payload.titleText });\n    return { title: payload.titleText };\n  }\n\n  const mediaType: \"movie\" | \"tv\" = match.media_type === \"tv\" ? \"tv\" : \"movie\";\n  const detailsUrl = `${TMDB_BASE_URL}/${mediaType}/${match.id}?api_key=${apiKey}`;\n  log(\"TMDb details\", { detailsUrl, mediaType });\n  const details = await fetchJson(detailsUrl);\n\n  const releaseDate =\n    mediaType === \"tv\"\n      ? details.first_air_date ?? match.first_air_date\n      : details.release_date ?? match.release_date;\n  const releaseYear = releaseDate ? Number(releaseDate.slice(0, 4)) : undefined;\n\n  const resolved: ResolvedTitle = {\n    title: (details.title ?? details.name) ?? payload.titleText ?? \"Unknown title\",\n    tmdbId: details.id,\n    tmdbVoteAverage: details.vote_average,\n    tmdbVoteCount: details.vote_count,\n    posterPath: details.poster_path ?? undefined,\n    releaseYear: Number.isNaN(releaseYear) ? undefined : releaseYear,\n    tmdbMediaType: mediaType,\n    tmdbGenres: Array.isArray(details.genres)\n      ? details.genres.map((genre: { name: string }) => genre.name.toLowerCase())\n      : []\n  };\n\n  const { tmdbGenres, ...cachePayload } = resolved;\n  void tmdbGenres;\n  cache[cacheKey] = { storedAt: Date.now(), data: cachePayload };\n  await setTmdbCache(cache);\n  log(\"TMDb cached result\", { cacheKey, tmdbId: resolved.tmdbId });\n\n  return resolved;\n};\n\nexport const getTmdbFeatures = async (\n  apiKey: string,\n  tmdbId: number,\n  mediaType: \"movie\" | \"tv\"\n): Promise<TmdbFeature | null> => {\n  const cache = await getFeatureCache();\n  const cacheKey = `${mediaType}:${tmdbId}`;\n  const cached = cache[cacheKey];\n  if (cached && Date.now() - cached.storedAt < TMDB_FEATURE_TTL_MS) {\n    return cached.data;\n  }\n\n  const detailsUrl = `${TMDB_BASE_URL}/${mediaType}/${tmdbId}?api_key=${apiKey}`;\n  const details = await fetchJson(detailsUrl);\n  const releaseDate = mediaType === \"tv\" ? details.first_air_date : details.release_date;\n  const releaseYear = releaseDate ? Number(releaseDate.slice(0, 4)) : undefined;\n  const features: TmdbFeature = {\n    tmdbId,\n    mediaType,\n    title: details.title ?? details.name,\n    releaseYear: Number.isNaN(releaseYear) ? undefined : releaseYear,\n    genres: Array.isArray(details.genres)\n      ? details.genres.map((genre: { name: string }) => genre.name.toLowerCase())\n      : []\n  };\n\n  cache[cacheKey] = { storedAt: Date.now(), data: features };\n  await setFeatureCache(cache);\n  return features;\n};\n\nexport const searchTmdbId = async (\n  apiKey: string,\n  titleText: string,\n  year?: number,\n  cache?: TmdbCacheState\n): Promise<{ tmdbId: number; title?: string; releaseYear?: number; mediaType: \"movie\" } | null> => {\n  if (cache) {\n    const key = buildTmdbCacheKey(titleText, year);\n    const cached = cache[key];\n    if (cached?.data?.tmdbId) {\n      return {\n        tmdbId: cached.data.tmdbId,\n        title: cached.data.title,\n        releaseYear: cached.data.releaseYear,\n        mediaType: \"movie\"\n      };\n    }\n  }\n  const params = new URLSearchParams({\n    api_key: apiKey,\n    query: titleText\n  });\n  if (year) params.set(\"year\", String(year));\n  const searchUrl = `${TMDB_BASE_URL}/search/movie?${params.toString()}`;\n  const searchData = await fetchJson(searchUrl);\n  const match = pickBestMatch(searchData?.results ?? [], titleText, year);\n  if (!match?.id) return null;\n  const releaseYear = match.release_date ? Number(match.release_date.slice(0, 4)) : undefined;\n  return {\n    tmdbId: match.id,\n    title: match.title,\n    releaseYear: Number.isNaN(releaseYear) ? undefined : releaseYear,\n    mediaType: \"movie\"\n  };\n};\n\nexport const getTmdbCacheSnapshot = async (): Promise<TmdbCacheState> => getTmdbCache();\n","import { log } from \"../../shared/logger\";\nimport { STORAGE_KEYS } from \"../../shared/constants\";\nimport { buildLetterboxdKey, parseLetterboxdKey } from \"../../shared/normalize\";\nimport type { LetterboxdIndex, ResolveTitleMessage } from \"../../shared/types\";\nimport { getLetterboxdIndex as loadLetterboxdIndex } from \"../../shared/storage\";\nimport {\n  getTmdbApiKey,\n  getTmdbFeatures,\n  getTmdbCacheSnapshot,\n  searchTmdbId\n} from \"../tmdb\";\n\nconst PROFILE_TTL_MS = 24 * 60 * 60 * 1000;\n\ntype MatchProfile = {\n  storedAt: number;\n  lastImportAt?: string;\n  meanRating: number;\n  genreStats: Record<string, { avg: number; count: number; strength: number }>;\n  decadeStats: Record<string, { avg: number; count: number; strength: number }>;\n};\n\nconst getLetterboxdIndex = async (): Promise<LetterboxdIndex | null> => {\n  return loadLetterboxdIndex();\n};\n\nconst getLetterboxdStats = async (): Promise<{ importedAt?: string } | null> => {\n  const data = await chrome.storage.local.get([STORAGE_KEYS.LETTERBOXD_STATS]);\n  return (data[STORAGE_KEYS.LETTERBOXD_STATS] as { importedAt?: string } | undefined) ?? null;\n};\n\nconst getMatchProfileCache = async (): Promise<MatchProfile | null> => {\n  const data = await chrome.storage.local.get([STORAGE_KEYS.MATCH_PROFILE]);\n  return (data[STORAGE_KEYS.MATCH_PROFILE] as MatchProfile | undefined) ?? null;\n};\n\nconst setMatchProfileCache = async (profile: MatchProfile) => {\n  await chrome.storage.local.set({ [STORAGE_KEYS.MATCH_PROFILE]: profile });\n};\n\nexport const resolveLetterboxdEntry = async (\n  payload: ResolveTitleMessage[\"payload\"],\n  resolvedTitle?: string,\n  resolvedYear?: number\n) => {\n  const index = await getLetterboxdIndex();\n  if (!index) {\n    log(\"LB_INDEX_LOADED\", { found: false });\n    return {};\n  }\n  log(\"LB_INDEX_LOADED\", { found: true, updatedAt: index.updatedAt });\n  const keys = [\n    buildLetterboxdKey(payload.titleText, payload.year),\n    buildLetterboxdKey(resolvedTitle, resolvedYear),\n    buildLetterboxdKey(payload.titleText, undefined),\n    buildLetterboxdKey(resolvedTitle, undefined)\n  ].filter((key) => key);\n\n  for (const key of keys) {\n    if (index.watchlistKeys[key] || index.ratingsByKey[key] !== undefined) {\n      log(\"LB_MATCH_FOUND\", { key });\n      return {\n        inWatchlist: index.watchlistKeys[key] === true,\n        userRating: index.ratingsByKey[key]\n      };\n    }\n  }\n\n  log(\"LB_MATCH_NOT_FOUND\", { keys, title: resolvedTitle ?? payload.titleText });\n  return {};\n};\n\nexport const buildMatchProfile = async (): Promise<MatchProfile | null> => {\n  const apiKey = await getTmdbApiKey();\n  if (!apiKey) return null;\n\n  const stats = await getLetterboxdStats();\n  const cached = await getMatchProfileCache();\n  if (\n    cached &&\n    Date.now() - cached.storedAt < PROFILE_TTL_MS &&\n    cached.lastImportAt &&\n    stats?.importedAt &&\n    cached.lastImportAt === stats.importedAt\n  ) {\n    return cached;\n  }\n\n  const index = await getLetterboxdIndex();\n  if (!index) return null;\n  const tmdbCache = await getTmdbCacheSnapshot();\n  const entries = Object.entries(index.ratingsByKey);\n  if (!entries.length) return null;\n\n  let ratingSum = 0;\n  let ratingCount = 0;\n  const genreTotals: Record<string, { sum: number; count: number }> = {};\n  const decadeTotals: Record<string, { sum: number; count: number }> = {};\n\n  const maxEntries = 300;\n  for (const [key, rating] of entries.slice(0, maxEntries)) {\n    ratingSum += rating;\n    ratingCount += 1;\n\n    const { title, year } = parseLetterboxdKey(key);\n    if (!title) continue;\n\n    const searchResult = await searchTmdbId(apiKey, title, year, tmdbCache);\n    if (!searchResult) continue;\n\n    const features = await getTmdbFeatures(apiKey, searchResult.tmdbId, searchResult.mediaType);\n    if (!features) continue;\n\n    const releaseYear = features.releaseYear ?? searchResult.releaseYear ?? year;\n    const decade = releaseYear ? `${Math.floor(releaseYear / 10) * 10}s` : undefined;\n\n    features.genres.forEach((genre) => {\n      if (!genreTotals[genre]) genreTotals[genre] = { sum: 0, count: 0 };\n      genreTotals[genre].sum += rating;\n      genreTotals[genre].count += 1;\n    });\n\n    if (decade) {\n      if (!decadeTotals[decade]) decadeTotals[decade] = { sum: 0, count: 0 };\n      decadeTotals[decade].sum += rating;\n      decadeTotals[decade].count += 1;\n    }\n  }\n\n  const meanRating = ratingCount ? ratingSum / ratingCount : 0;\n  const genreStats: MatchProfile[\"genreStats\"] = {};\n  const decadeStats: MatchProfile[\"decadeStats\"] = {};\n\n  Object.entries(genreTotals).forEach(([genre, { sum, count }]) => {\n    const avg = sum / count;\n    genreStats[genre] = {\n      avg,\n      count,\n      strength: avg - meanRating\n    };\n  });\n\n  Object.entries(decadeTotals).forEach(([decade, { sum, count }]) => {\n    const avg = sum / count;\n    decadeStats[decade] = {\n      avg,\n      count,\n      strength: avg - meanRating\n    };\n  });\n\n  const profile: MatchProfile = {\n    storedAt: Date.now(),\n    lastImportAt: stats?.importedAt,\n    meanRating,\n    genreStats,\n    decadeStats\n  };\n\n  await setMatchProfileCache(profile);\n  return profile;\n};\n\nexport const computeMatchScore = (\n  profile: MatchProfile | null,\n  candidateGenres: string[]\n): { matchScore?: number; matchExplanation?: string } => {\n  if (!profile || !candidateGenres.length) return {};\n\n  let weightedSum = 0;\n  let totalWeight = 0;\n  const positives: { genre: string; strength: number }[] = [];\n\n  candidateGenres.forEach((genre) => {\n    const normalized = genre.toLowerCase();\n    const stats = profile.genreStats[normalized];\n    if (!stats) return;\n    const confidence = Math.min(1, stats.count / 5);\n    const strength = stats.strength;\n    weightedSum += strength * confidence;\n    totalWeight += confidence;\n    if (strength > 0) {\n      positives.push({ genre: normalized, strength });\n    }\n  });\n\n  if (totalWeight === 0) return {};\n  const normalized = weightedSum / totalWeight;\n  const score = Math.round(Math.max(0, Math.min(100, 50 + normalized * 20)));\n\n  const topGenres = positives\n    .sort((a, b) => b.strength - a.strength)\n    .slice(0, 2)\n    .map((entry) => entry.genre);\n  const explanation =\n    topGenres.length > 0 ? `Because you like ${topGenres.join(\", \")}` : undefined;\n\n  return { matchScore: score, matchExplanation: explanation };\n};\n","import { log } from \"../../shared/logger\";\nimport { STORAGE_KEYS } from \"../../shared/constants\";\nimport type {\n  ExtensionRuntimeMessage,\n  LetterboxdIndexUpdatedAckMessage,\n  LetterboxdIndexUpdatedMessage,\n  ResolveTitleMessage,\n  TitleResolvedMessage\n} from \"../../shared/types\";\nimport { resolveTitleWithTmdb } from \"../tmdb\";\nimport { buildMatchProfile, computeMatchScore, resolveLetterboxdEntry } from \"../letterboxd\";\n\nexport const registerMessageHandlers = () => {\n  chrome.runtime.onMessage.addListener(\n    (message: ExtensionRuntimeMessage, sender, sendResponse) => {\n      log(\"Background received message\", { message, sender });\n\n      if (message.type === \"LB_INDEX_UPDATED\") {\n        const updated = message as LetterboxdIndexUpdatedMessage;\n        void updated;\n        void (async () => {\n          await chrome.storage.local.remove([STORAGE_KEYS.MATCH_PROFILE]);\n          log(\"LB_INDEX_UPDATED\");\n          const ack: LetterboxdIndexUpdatedAckMessage = {\n            type: \"LB_INDEX_UPDATED_ACK\",\n            payload: { updatedAt: Date.now() }\n          };\n          try {\n            chrome.runtime.sendMessage(ack).catch(() => undefined);\n          } catch {\n            // noop\n          }\n          sendResponse(ack);\n        })();\n        return true;\n      }\n\n      if (message.type === \"RESOLVE_TITLE\") {\n        const { requestId, payload } = message as ResolveTitleMessage;\n\n        void (async () => {\n          try {\n            const resolved = await resolveTitleWithTmdb(payload);\n            const lbData = await resolveLetterboxdEntry(\n              payload,\n              resolved.title,\n              resolved.releaseYear ?? payload.year\n            );\n            const profile = await buildMatchProfile();\n            const matchData = computeMatchScore(profile, resolved.tmdbGenres ?? []);\n            const { tmdbGenres, ...resolvedPayload } = resolved;\n            void tmdbGenres;\n            const response: TitleResolvedMessage = {\n              type: \"TITLE_RESOLVED\",\n              requestId,\n              payload: {\n                ...resolvedPayload,\n                ...lbData,\n                ...matchData\n              }\n            };\n            sendResponse(response);\n          } catch (error) {\n            log(\"TMDb resolve failed\", { error });\n            const lbData = await resolveLetterboxdEntry(\n              payload,\n              payload.titleText ?? \"Unknown title\",\n              payload.year\n            );\n            sendResponse({\n              type: \"TITLE_RESOLVED\",\n              requestId,\n              payload: {\n                title: payload.titleText ?? \"Unknown title\",\n                ...lbData\n              }\n            } satisfies TitleResolvedMessage);\n          }\n        })();\n\n        return true;\n      }\n\n      return false;\n    }\n  );\n};\n","import { log } from \"../shared/logger\";\nimport { registerMessageHandlers } from \"./messaging\";\n\nchrome.runtime.onInstalled.addListener((details) => {\n  log(\"Extension installed\", details);\n});\n\nregisterMessageHandlers();\n"],"names":["TMDB_BASE_URL","TMDB_CACHE_TTL_MS","TMDB_FEATURE_TTL_MS","getTmdbCache","STORAGE_KEYS","setTmdbCache","cache","getFeatureCache","setFeatureCache","getTmdbApiKey","key","pickBestMatch","results","titleText","year","normalized","normalizeTitle","exactTitleAndYear","item","resultTitle","releaseDate","releaseYear","exactTitle","fetchJson","url","response","resolveTitleWithTmdb","payload","apiKey","cacheKey","buildTmdbCacheKey","cached","mediaType","features","getTmdbFeatures","params","searchUrl","searchData","filtered","match","log","detailsUrl","details","resolved","genre","tmdbGenres","cachePayload","tmdbId","searchTmdbId","_a","getTmdbCacheSnapshot","PROFILE_TTL_MS","getLetterboxdIndex","loadLetterboxdIndex","getLetterboxdStats","getMatchProfileCache","setMatchProfileCache","profile","resolveLetterboxdEntry","resolvedTitle","resolvedYear","index","keys","buildLetterboxdKey","buildMatchProfile","stats","tmdbCache","entries","ratingSum","ratingCount","genreTotals","decadeTotals","maxEntries","rating","title","parseLetterboxdKey","searchResult","decade","meanRating","genreStats","decadeStats","sum","count","avg","computeMatchScore","candidateGenres","weightedSum","totalWeight","positives","confidence","strength","score","topGenres","a","b","entry","explanation","registerMessageHandlers","message","sender","sendResponse","ack","requestId","lbData","matchData","resolvedPayload"],"mappings":"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"}