{"version":3,"file":"index.js","sources":["../../src/shared/constants.ts","../../src/shared/logger.ts","../../src/shared/normalize.ts","../../src/shared/storage.ts","../../src/content/netflix/selectors.ts","../../src/content/ui/overlay/index.ts","../../src/content/ui/badge/index.ts","../../src/content/netflix/observer.ts","../../src/content/index.ts"],"sourcesContent":["export const DEBUG = true;\n\nexport const STORAGE_KEYS = {\n  OVERLAY_ENABLED: \"overlayEnabled\",\n  TMDB_API_KEY: \"tmdbApiKey\",\n  TMDB_CACHE: \"tmdbCache\",\n  TMDB_FEATURE_CACHE: \"tmdbFeatureCache\",\n  MATCH_PROFILE: \"matchProfile\",\n  LETTERBOXD_INDEX: \"lb_index_v1\",\n  LETTERBOXD_STATS: \"lb_stats_v1\",\n  LAST_IMPORT_AT: \"lastImportAt\"\n} as const;\n\nexport type StorageKey = (typeof STORAGE_KEYS)[keyof typeof STORAGE_KEYS];\n","import { DEBUG } from \"./constants\";\n\nexport { DEBUG };\n\nexport const log = (...args: unknown[]) => {\n  if (!DEBUG) return;\n  console.log(\"[Netflix+Letterboxd]\", ...args);\n};\n\nexport const warn = (...args: unknown[]) => {\n  if (!DEBUG) return;\n  console.warn(\"[Netflix+Letterboxd]\", ...args);\n};\n\nexport const error = (...args: unknown[]) => {\n  if (!DEBUG) return;\n  console.error(\"[Netflix+Letterboxd]\", ...args);\n};\n","export const normalizeTitle = (title?: string): string => {\n  if (!title) return \"\";\n  return title\n    .toLowerCase()\n    .replace(/&/g, \" and \")\n    .replace(/[^a-z0-9']+/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n};\n\nexport const makeKey = (title?: string, year?: number): string => {\n  const normalized = normalizeTitle(title);\n  const suffix = year ? String(year) : \"\";\n  return `${normalized}-${suffix}`;\n};\n\nexport const buildTmdbCacheKey = (title?: string, year?: number): string => {\n  const normalized = normalizeTitle(title);\n  return year ? `${normalized} (${year})` : normalized;\n};\n\nexport const buildLetterboxdKey = (title?: string, year?: number): string => {\n  return makeKey(title, year);\n};\n\nexport const parseLetterboxdKey = (key: string): { title: string; year?: number } => {\n  const parts = key.split(\"-\");\n  if (parts.length >= 2) {\n    const maybeYear = parts[parts.length - 1];\n    if (maybeYear === \"\") {\n      return { title: parts.slice(0, -1).join(\"-\") };\n    }\n    const year = Number(maybeYear);\n    if (!Number.isNaN(year) && maybeYear.length === 4) {\n      return { title: parts.slice(0, -1).join(\"-\"), year };\n    }\n  }\n  return { title: key };\n};\n\nexport const buildLegacyLetterboxdKey = (title?: string, year?: number): string => {\n  const normalized = normalizeTitle(title);\n  return year ? `${normalized}|${year}` : normalized;\n};\n\nexport const parseLegacyLetterboxdKey = (key: string): { title: string; year?: number } => {\n  const parts = key.split(\"|\");\n  if (parts.length === 2) {\n    const year = Number(parts[1]);\n    return { title: parts[0], year: Number.isNaN(year) ? undefined : year };\n  }\n  return { title: key };\n};\n","import { log, warn } from \"./logger\";\nimport { STORAGE_KEYS } from \"./constants\";\nimport { makeKey, parseLegacyLetterboxdKey } from \"./normalize\";\nimport type { LetterboxdIndex, LetterboxdIndexLegacy, LetterboxdStats } from \"./types\";\n\nexport interface StorageState {\n  [STORAGE_KEYS.OVERLAY_ENABLED]?: boolean;\n  [STORAGE_KEYS.TMDB_API_KEY]?: string;\n  [STORAGE_KEYS.TMDB_CACHE]?: Record<string, unknown>;\n  [STORAGE_KEYS.TMDB_FEATURE_CACHE]?: Record<string, unknown>;\n  [STORAGE_KEYS.MATCH_PROFILE]?: Record<string, unknown>;\n  [STORAGE_KEYS.LETTERBOXD_INDEX]?: LetterboxdIndex | LetterboxdIndexLegacy;\n  [STORAGE_KEYS.LETTERBOXD_STATS]?: LetterboxdStats;\n  [STORAGE_KEYS.LAST_IMPORT_AT]?: string;\n}\n\nexport const getStorage = async (): Promise<StorageState> => {\n  log(\"Loading storage state\");\n  return chrome.storage.local.get([\n    STORAGE_KEYS.OVERLAY_ENABLED,\n    STORAGE_KEYS.TMDB_API_KEY,\n    STORAGE_KEYS.TMDB_CACHE,\n    STORAGE_KEYS.TMDB_FEATURE_CACHE,\n    STORAGE_KEYS.MATCH_PROFILE,\n    STORAGE_KEYS.LETTERBOXD_INDEX,\n    STORAGE_KEYS.LETTERBOXD_STATS,\n    STORAGE_KEYS.LAST_IMPORT_AT\n  ]) as Promise<StorageState>;\n};\n\nexport const setStorage = async (state: StorageState): Promise<void> => {\n  log(\"Saving storage state\", state);\n  await chrome.storage.local.set(state);\n};\n\nexport const clearStorage = async (): Promise<void> => {\n  warn(\"Clearing storage state\");\n  await chrome.storage.local.clear();\n};\n\nexport const getLetterboxdIndex = async (): Promise<LetterboxdIndex | null> => {\n  const data = await chrome.storage.local.get([STORAGE_KEYS.LETTERBOXD_INDEX]);\n  const raw = data[STORAGE_KEYS.LETTERBOXD_INDEX] as\n    | LetterboxdIndex\n    | LetterboxdIndexLegacy\n    | undefined;\n  if (!raw) return null;\n\n  if (\"ratingsByKey\" in raw && \"watchlistKeys\" in raw) {\n    const index = raw as LetterboxdIndex;\n    const needsMigration =\n      Object.keys(index.ratingsByKey).some((key) => key.includes(\"|\")) ||\n      Object.keys(index.watchlistKeys).some((key) => key.includes(\"|\"));\n    if (!needsMigration) return index;\n    const migratedRatings: Record<string, number> = {};\n    const migratedWatchlist: Record<string, true> = {};\n    Object.entries(index.ratingsByKey).forEach(([key, rating]) => {\n      const parsed = parseLegacyLetterboxdKey(key);\n      const nextKey = makeKey(parsed.title, parsed.year);\n      migratedRatings[nextKey] = rating;\n    });\n    Object.keys(index.watchlistKeys).forEach((key) => {\n      const parsed = parseLegacyLetterboxdKey(key);\n      const nextKey = makeKey(parsed.title, parsed.year);\n      migratedWatchlist[nextKey] = true;\n    });\n    return {\n      ratingsByKey: migratedRatings,\n      watchlistKeys: migratedWatchlist,\n      updatedAt: Date.now()\n    };\n  }\n\n  const legacy = raw as LetterboxdIndexLegacy;\n  const ratingsByKey: Record<string, number> = {};\n  const watchlistKeys: Record<string, true> = {};\n  Object.entries(legacy).forEach(([key, entry]) => {\n    const parsed = parseLegacyLetterboxdKey(key);\n    const nextKey = makeKey(parsed.title, parsed.year);\n    if (entry.r !== undefined) ratingsByKey[nextKey] = entry.r;\n    if (entry.w === 1) watchlistKeys[nextKey] = true;\n  });\n  return {\n    ratingsByKey,\n    watchlistKeys,\n    updatedAt: Date.now()\n  };\n};\n\nexport const setLetterboxdIndex = async (index: LetterboxdIndex): Promise<void> => {\n  await chrome.storage.local.set({ [STORAGE_KEYS.LETTERBOXD_INDEX]: index });\n};\n","import { normalizeTitle } from \"../../shared/normalize\";\nimport type { ExtractedTitleInfo } from \"../../shared/types\";\n\nexport interface ActiveTitleCandidate {\n  netflixTitleId?: string;\n  titleText?: string;\n  year?: number;\n  href?: string;\n  source: string;\n}\n\nconst TITLE_ANCHOR_SELECTOR = \"a[href^='/title/']\";\n\nconst CONTAINER_SELECTORS = [\n  \"[role='dialog']\",\n  \"[aria-modal='true']\",\n  \"[aria-expanded='true']\",\n  \"[data-uia*='jawbone']\",\n  \"[class*='jawbone']\",\n  \"[data-uia*='preview']\",\n  \"[data-uia*='billboard']\",\n  \"[data-uia*='hero']\",\n  \"[data-uia*='details']\"\n];\n\nexport const EXPANDED_CONTAINER_SELECTOR = CONTAINER_SELECTORS.join(\",\");\n\nconst TITLE_TEXT_SELECTORS = [\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"[data-uia*='title']\",\n  \"[class*='title']\",\n  \"[class*='fallback']\",\n  \"[class*='preview'] [class*='header']\"\n];\n\nconst PREVIEW_SELECTORS = [\n  \"video\",\n  \"img\",\n  \"[data-uia*='preview'] video\",\n  \"[data-uia*='preview'] img\",\n  \"[class*='preview'] video\",\n  \"[class*='preview'] img\",\n  \"[data-uia*='player'] video\",\n  \"[data-uia*='hero'] img\"\n];\n\nconst CONTROLS_SELECTORS = [\n  \"[data-uia*='controls']\",\n  \"[class*='controls']\",\n  \"[class*='control']\",\n  \"[role='toolbar']\"\n];\n\nconst EPISODE_TITLE_PATTERN =\n  /(S\\d+\\s*:?\\s*E\\d+|Season\\s*\\d+\\s*Episode\\s*\\d+|Episode\\s*\\d+|\\bE\\d+\\b)/i;\nconst EPISODE_TIME_PATTERN = /(\\b\\d+\\s*(m|min|minutes)\\b|\\b\\d+\\s*of\\s*\\d+\\s*(m|min|minutes)\\b)/i;\nconst METADATA_TEXT_PATTERN =\n  /\\b(tv-[a-z0-9]+|pg-?13|pg|tv-ma|tv-y|tv-g|nr|nc-17|hd|uhd|4k|seasons?|season|episode|volume|part\\s+\\d+)\\b/i;\nconst ACTION_TEXT_PATTERN =\n  /^(play|resume|continue|more info|details|watch|watch now|watch again|add|added|my list|remove|rate|like|dislike|thumbs up|thumbs down)$/i;\nconst CONTEXT_TEXT_PATTERN = /because you watched/i;\n\nconst METADATA_SELECTORS = [\n  \"[data-uia*='maturity-rating']\",\n  \"[data-uia*='season']\",\n  \"[data-uia*='resolution']\",\n  \"[data-uia*='hd']\",\n  \"[class*='maturity']\",\n  \"[class*='season']\",\n  \"[class*='quality']\"\n];\n\nconst GENRE_SELECTORS = [\n  \"[data-uia*='genre']\",\n  \"a[href*='/genre/']\",\n  \"[class*='genre']\"\n];\n\nconst METADATA_CONTAINER_SELECTORS = [\n  ...METADATA_SELECTORS,\n  ...GENRE_SELECTORS,\n  \"[data-uia*='metadata']\",\n  \"[class*='metadata']\",\n  \"[class*='meta']\",\n  \"[class*='maturity']\",\n  \"[class*='season']\",\n  \"[class*='genre']\",\n  \"[class*='tag']\",\n  \"[class*='info']\"\n];\n\nconst HEADER_CONTAINER_SELECTORS = [\n  \"header\",\n  \"nav\",\n  \"[data-uia*='header']\",\n  \"[data-uia*='row-title']\",\n  \"[class*='rowHeader']\",\n  \"[class*='row-title']\"\n];\n\nconst TITLE_LIKE_SELECTORS = [\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"[data-uia*='title']\",\n  \"[class*='title']\",\n  \"[class*='headline']\",\n  \"[class*='header']\",\n  \"[class*='name']\"\n];\n\nconst NAV_BANNED_PATTERN =\n  /(browse|home|my list|popular|your next watch|explore all|movies & shows|movies and shows|new & popular)/i;\n\nconst isVisible = (el: Element): boolean => {\n  const rect = el.getBoundingClientRect();\n  if (rect.width === 0 || rect.height === 0) return false;\n  const style = window.getComputedStyle(el as HTMLElement);\n  if (style.visibility === \"hidden\" || style.display === \"none\" || style.opacity === \"0\") {\n    return false;\n  }\n  const inViewport =\n    rect.bottom >= 0 &&\n    rect.right >= 0 &&\n    rect.top <= window.innerHeight &&\n    rect.left <= window.innerWidth;\n  return inViewport;\n};\n\nconst normalizeText = (value?: string | null): string | undefined => {\n  if (!value) return undefined;\n  const text = value.replace(/\\s+/g, \" \").trim();\n  return text.length ? text : undefined;\n};\n\nconst parseTitleIdFromHref = (href?: string | null): string | undefined => {\n  if (!href) return undefined;\n  const match = href.match(/\\/title\\/(\\d+)/);\n  return match?.[1];\n};\n\nconst parseYearFromText = (text?: string): number | undefined => {\n  if (!text) return undefined;\n  const match = text.match(/(19\\d{2}|20\\d{2})/);\n  if (!match) return undefined;\n  const year = Number(match[1]);\n  if (Number.isNaN(year)) return undefined;\n  return year;\n};\n\nexport const normalizeNetflixTitle = (raw?: string): string | undefined => {\n  if (!raw) return undefined;\n  let value = raw;\n  value = value.replace(/^\\s*S\\d+\\s*:?\\s*E\\d+\\s*/i, \"\");\n  value = value.replace(/\"[^\"]*\"/g, (match) => {\n    const inner = match.replace(/\"/g, \"\");\n    return EPISODE_TITLE_PATTERN.test(inner) ? \"\" : match;\n  });\n  value = value.replace(/Episode\\s*\\d+/gi, \"\");\n  value = value.replace(/\\bE\\d+\\b/gi, \"\");\n  value = value.replace(EPISODE_TIME_PATTERN, \"\");\n  value = value.replace(/\\s+of\\s+\\d+\\s*(m|min|minutes)?/gi, \"\");\n  value = value.replace(/\\s+/g, \" \").trim();\n  return value.length ? value : undefined;\n};\n\nconst extractFromAnchor = (anchor: HTMLAnchorElement, source: string): ActiveTitleCandidate => {\n  const href = anchor.getAttribute(\"href\") || undefined;\n  const netflixTitleId = parseTitleIdFromHref(href);\n  const titleText = normalizeText(anchor.getAttribute(\"aria-label\") || anchor.textContent);\n  return { netflixTitleId, titleText, href, source };\n};\n\nconst extractTitleTextNear = (container: Element): string | undefined => {\n  for (const selector of TITLE_TEXT_SELECTORS) {\n    const el = container.querySelector(selector);\n    if (el && isVisible(el)) {\n      const text = normalizeText(el.textContent);\n      if (text) return text;\n    }\n  }\n  return undefined;\n};\n\nexport const getRawTitleText = (container?: Element | null): string | undefined => {\n  if (!container) return undefined;\n  return extractTitleTextNear(container);\n};\n\nconst findPrimaryTitle = (container?: Element | null): string | undefined => {\n  if (!container) return undefined;\n  for (const selector of TITLE_TEXT_SELECTORS) {\n    const nodes = Array.from(container.querySelectorAll(selector));\n    for (const node of nodes) {\n      if (!isVisible(node)) continue;\n      const text = normalizeText(node.textContent);\n      if (!text) continue;\n      if (EPISODE_TITLE_PATTERN.test(text) || EPISODE_TIME_PATTERN.test(text)) continue;\n      const normalized = normalizeNetflixTitle(text);\n      if (normalized) return normalized;\n    }\n  }\n  return undefined;\n};\n\nexport const findOverlayAnchor = (container?: Element | null): Element | null => {\n  if (container) {\n    const anchor = findBestAnchorIn(container);\n    if (anchor && isVisible(anchor)) return anchor;\n    for (const selector of TITLE_TEXT_SELECTORS) {\n      const el = container.querySelector(selector);\n      if (el && isVisible(el)) return el;\n    }\n  }\n\n  const pageAnchor = Array.from(\n    document.querySelectorAll<HTMLAnchorElement>(TITLE_ANCHOR_SELECTOR)\n  ).find(isVisible);\n  if (pageAnchor) return pageAnchor;\n\n  const pageTitle = Array.from(document.querySelectorAll(TITLE_TEXT_SELECTORS.join(\",\"))).find(\n    isVisible\n  );\n  return pageTitle ?? null;\n};\n\nexport const findPreviewElement = (container?: Element | null): Element | null => {\n  if (!container) return null;\n  const candidates: Element[] = [];\n  PREVIEW_SELECTORS.forEach((selector) => {\n    container.querySelectorAll(selector).forEach((el) => {\n      if (isVisible(el)) candidates.push(el);\n    });\n  });\n  if (!candidates.length) return null;\n  return candidates.reduce((best, current) => {\n    const bestRect = best.getBoundingClientRect();\n    const currentRect = current.getBoundingClientRect();\n    const bestArea = bestRect.width * bestRect.height;\n    const currentArea = currentRect.width * currentRect.height;\n    return currentArea > bestArea ? current : best;\n  });\n};\n\nexport const findControlsRow = (root?: Element | null): HTMLElement | null => {\n  if (!root) return null;\n  const candidates: HTMLElement[] = [];\n  CONTROLS_SELECTORS.forEach((selector) => {\n    root.querySelectorAll<HTMLElement>(selector).forEach((el) => {\n      if (!isVisible(el)) return;\n      candidates.push(el);\n    });\n  });\n  const unique = Array.from(new Set(candidates));\n  const scored = unique\n    .map((el) => {\n      const buttons = el.querySelectorAll(\"button, [role='button']\").length;\n      const rect = el.getBoundingClientRect();\n      const score = buttons * 10 + rect.width;\n      return { el, score, top: rect.top };\n    })\n    .filter((entry) => entry.score > 0);\n  scored.sort((a, b) => b.score - a.score || b.top - a.top);\n  return scored[0]?.el ?? null;\n};\n\nexport const hasMetadataSection = (root?: Element | null): boolean => {\n  if (!root) return false;\n  const selectors = [...METADATA_SELECTORS, ...GENRE_SELECTORS].join(\",\");\n  const nodes = Array.from(root.querySelectorAll(selectors));\n  return nodes.some((node) => isVisible(node));\n};\n\nexport const findExpandedRoot = (): HTMLElement | null => {\n  const candidates = collectJawboneCandidates();\n  const maxWidth = window.innerWidth * 0.85;\n  const maxHeight = window.innerHeight * 0.6;\n  for (const candidate of candidates) {\n    const rect = candidate.getBoundingClientRect();\n    if (rect.width > maxWidth || rect.height > maxHeight) continue;\n    const preview = findPreviewElement(candidate);\n    const controls = findControlsRow(candidate);\n    const metadata = hasMetadataSection(candidate);\n    if (preview && controls && metadata) {\n      return candidate as HTMLElement;\n    }\n  }\n  return null;\n};\n\nconst isInMetadataRegion = (el: Element) =>\n  Boolean(el.closest(METADATA_CONTAINER_SELECTORS.join(\",\")));\n\nconst isInHeaderRegion = (el: Element) =>\n  Boolean(el.closest(HEADER_CONTAINER_SELECTORS.join(\",\")));\n\nconst isBannedTitleText = (text: string) => {\n  if (NAV_BANNED_PATTERN.test(text)) return true;\n  if (ACTION_TEXT_PATTERN.test(text.trim())) return true;\n  if (CONTEXT_TEXT_PATTERN.test(text)) return true;\n  if (METADATA_TEXT_PATTERN.test(text)) return true;\n  return (\n    EPISODE_TITLE_PATTERN.test(text) ||\n    EPISODE_TIME_PATTERN.test(text) ||\n    /\\b\\d+\\s*of\\s*\\d+\\s*(m|min|minutes)?\\b/i.test(text) ||\n    /\\b\\d+\\s*(m|min|minutes)\\b/i.test(text)\n  );\n};\n\nconst isInProgressRegion = (el: Element, controlsTop?: number) => {\n  if (el.closest('[role=\"progressbar\"], [data-uia*=\"progress\"], [class*=\"progress\"]')) {\n    return true;\n  }\n  if (controlsTop !== undefined) {\n    const rect = el.getBoundingClientRect();\n    return rect.bottom >= controlsTop - 8;\n  }\n  return false;\n};\n\nconst isInControlsRegion = (el: Element, controls?: Element | null) => {\n  if (!el) return false;\n  if (controls && (controls.contains(el) || el.closest(\"button, [role='button']\"))) {\n    return true;\n  }\n  return Boolean(\n    el.closest(\"button, [role='button'], [data-uia*='play'], [data-uia*='button']\")\n  );\n};\n\nexport const extractDisplayTitle = (expandedRoot: HTMLElement): {\n  title: string | null;\n  chosen?: Element;\n  rejectedCount: number;\n} => {\n  const rootRect = expandedRoot.getBoundingClientRect();\n  const controls = findControlsRow(expandedRoot);\n  const controlsTop = controls ? controls.getBoundingClientRect().top : undefined;\n  const candidates = Array.from(expandedRoot.querySelectorAll(TITLE_LIKE_SELECTORS.join(\",\")));\n  let best: { el: Element; score: number; text: string } | undefined;\n  let rejectedCount = 0;\n  const episodeNodes: Element[] = [];\n\n  candidates.forEach((el) => {\n    if (!isVisible(el)) {\n      rejectedCount += 1;\n      return;\n    }\n    if (isInControlsRegion(el, controls)) {\n      rejectedCount += 1;\n      return;\n    }\n    if (isInProgressRegion(el, controlsTop)) {\n      rejectedCount += 1;\n      return;\n    }\n    const text = normalizeText(el.textContent);\n    if (!text || text.length < 2 || text.length > 80) {\n      rejectedCount += 1;\n      return;\n    }\n    if (isBannedTitleText(text)) {\n      episodeNodes.push(el);\n      rejectedCount += 1;\n      return;\n    }\n\n    const rect = el.getBoundingClientRect();\n    const style = window.getComputedStyle(el as HTMLElement);\n    const fontSize = parseFloat(style.fontSize) || 14;\n    const fontWeightRaw = style.fontWeight === \"bold\" ? 700 : Number(style.fontWeight);\n    const fontWeight = Number.isNaN(fontWeightRaw) ? 400 : fontWeightRaw;\n    const dx = rect.left - rootRect.left;\n    const dy = rect.top - rootRect.top;\n    const dist = Math.hypot(dx, dy);\n    const regionPenalty =\n      isInMetadataRegion(el) || isInHeaderRegion(el) ? 120 : 0;\n    const score = fontSize * 10 + fontWeight / 10 + Math.max(0, 300 - dist) - regionPenalty;\n    if (!best || score > best.score) {\n      best = { el, score, text };\n    }\n  });\n\n  if (best) {\n    const normalized = normalizeNetflixTitle(best.text);\n    return { title: normalized ?? best.text, chosen: best.el, rejectedCount };\n  }\n\n  for (const episodeNode of episodeNodes) {\n    let current: Element | null = episodeNode.parentElement;\n    let depth = 0;\n    while (current && depth < 4) {\n      const siblingCandidates = Array.from(\n        current.querySelectorAll(TITLE_LIKE_SELECTORS.join(\",\"))\n      ).filter((el) => el !== episodeNode);\n      for (const sibling of siblingCandidates) {\n        if (!isVisible(sibling)) continue;\n        if (isInControlsRegion(sibling, controls)) continue;\n        if (isInProgressRegion(sibling, controlsTop)) continue;\n        const text = normalizeText(sibling.textContent);\n        if (!text || text.length < 2 || text.length > 80) continue;\n        if (isBannedTitleText(text)) continue;\n        return {\n          title: normalizeNetflixTitle(text) ?? text,\n          chosen: sibling,\n          rejectedCount\n        };\n      }\n      current = current.parentElement;\n      depth += 1;\n    }\n  }\n\n  const anchor = expandedRoot.querySelector(\"a[href^='/title/']\");\n  if (anchor) {\n    const heading = anchor.querySelector(TITLE_LIKE_SELECTORS.join(\",\"));\n    const directText = normalizeText(heading?.textContent || anchor.textContent);\n    if (directText && !isBannedTitleText(directText)) {\n      return {\n        title: normalizeNetflixTitle(directText) ?? directText,\n        chosen: heading ?? anchor,\n        rejectedCount\n      };\n    }\n\n    let current: Element | null = anchor.parentElement;\n    let depth = 0;\n    while (current && depth < 4) {\n      const nearby = Array.from(current.querySelectorAll(TITLE_LIKE_SELECTORS.join(\",\")));\n      for (const node of nearby) {\n        if (!isVisible(node)) continue;\n        if (isInControlsRegion(node, controls)) continue;\n        if (isInProgressRegion(node, controlsTop)) continue;\n        const text = normalizeText(node.textContent);\n        if (!text || text.length < 2 || text.length > 80) continue;\n        if (isBannedTitleText(text)) continue;\n        return {\n          title: normalizeNetflixTitle(text) ?? text,\n          chosen: node,\n          rejectedCount\n        };\n      }\n      current = current.parentElement;\n      depth += 1;\n    }\n  }\n\n  return { title: null, rejectedCount };\n};\n\nconst extractMetadataInfo = (root: HTMLElement): { year?: number; isSeries?: boolean } => {\n  const nodes = Array.from(root.querySelectorAll(METADATA_CONTAINER_SELECTORS.join(\",\")));\n  const texts = nodes\n    .map((node) => normalizeText(node.textContent))\n    .filter(Boolean) as string[];\n\n  if (!texts.length) {\n    const controls = findControlsRow(root);\n    const next = controls?.nextElementSibling as HTMLElement | null;\n    const nextText = normalizeText(next?.textContent);\n    if (nextText) texts.push(nextText);\n  }\n\n  const combined = texts.join(\" \");\n  const year = parseYearFromText(combined);\n  const hasSeasons = /\\bseasons?\\b/i.test(combined);\n  const hasRuntime = /\\b\\d+\\s*(m|min|minutes)\\b/i.test(combined) || /\\b\\d+\\s*h\\b/i.test(combined);\n\n  let isSeries: boolean | undefined = undefined;\n  if (hasSeasons) isSeries = true;\n  else if (hasRuntime) isSeries = false;\n\n  return { year, isSeries };\n};\n\nconst extractTitleFromAnchor = (anchor: HTMLAnchorElement): string | undefined => {\n  const candidates: Array<string | null | undefined> = [\n    anchor.getAttribute(\"aria-label\"),\n    anchor.getAttribute(\"title\"),\n    (anchor.querySelector(\"img[alt]\") as HTMLImageElement | null)?.alt,\n    (anchor.querySelector(\"[aria-label]\") as HTMLElement | null)?.getAttribute(\"aria-label\"),\n    anchor.textContent\n  ];\n  for (const candidate of candidates) {\n    const text = normalizeText(candidate);\n    if (!text) continue;\n    if (isBannedTitleText(text)) continue;\n    return text;\n  }\n  return undefined;\n};\n\nconst getBestTitleAnchor = (\n  root: HTMLElement,\n  previewEl?: Element | null,\n  controls?: Element | null\n) => {\n  const anchors = Array.from(root.querySelectorAll<HTMLAnchorElement>(\"a[href^='/title/']\"));\n  const visibleAnchors = anchors.filter((anchor) => isVisible(anchor));\n  if (!visibleAnchors.length) return null;\n\n  const previewRect = previewEl?.getBoundingClientRect();\n  let best: { anchor: HTMLAnchorElement; score: number } | null = null;\n\n  visibleAnchors.forEach((anchor) => {\n    if (isInHeaderRegion(anchor)) return;\n    if (isInControlsRegion(anchor, controls)) return;\n    const rect = anchor.getBoundingClientRect();\n    const area = rect.width * rect.height;\n    let score = 0;\n\n    if (previewEl && (anchor.contains(previewEl) || previewEl.contains(anchor))) {\n      score += 1000;\n    }\n\n    if (previewRect) {\n      const dx = rect.left + rect.width / 2 - (previewRect.left + previewRect.width / 2);\n      const dy = rect.top + rect.height / 2 - (previewRect.top + previewRect.height / 2);\n      const dist = Math.hypot(dx, dy);\n      score += Math.max(0, 500 - dist);\n    }\n\n    score += Math.min(area / 100, 200);\n\n    const anchorTitle = extractTitleFromAnchor(anchor);\n    if (anchorTitle) score += 50;\n\n    if (!best || score > best.score) {\n      best = { anchor, score };\n    }\n  });\n\n  return best?.anchor ?? null;\n};\n\nexport const findActiveJawbone = (): {\n  jawboneEl: HTMLElement | null;\n  extracted: ExtractedTitleInfo | null;\n  rejectedCount?: number;\n  chosenTitleElement?: Element;\n} => {\n  const candidates = collectJawboneCandidates();\n  const maxWidth = window.innerWidth * 0.85;\n  const maxHeight = window.innerHeight * 0.6;\n\n  for (const candidate of candidates) {\n    const rect = candidate.getBoundingClientRect();\n    if (rect.width > maxWidth || rect.height > maxHeight) continue;\n    const preview = findPreviewElement(candidate);\n    const controls = findControlsRow(candidate);\n    const metadata = hasMetadataSection(candidate);\n    if (!preview || !controls) continue;\n\n    const anchor = getBestTitleAnchor(candidate as HTMLElement, preview, controls);\n\n    const display = extractDisplayTitle(candidate as HTMLElement);\n    let title = display.title ?? null;\n    if (anchor) {\n      const anchorTitle = extractTitleFromAnchor(anchor);\n      if (anchorTitle) {\n        title = normalizeNetflixTitle(anchorTitle) ?? anchorTitle;\n      }\n    }\n    if (!title && !metadata) continue;\n    if (!title && metadata) {\n      const fallbackTitle = getRawTitleText(candidate);\n      if (fallbackTitle && !isBannedTitleText(fallbackTitle)) {\n        title = normalizeNetflixTitle(fallbackTitle) ?? fallbackTitle;\n      }\n    }\n    if (!title) continue;\n\n    const href = anchor?.getAttribute(\"href\") ?? null;\n    const netflixId = parseTitleIdFromHref(href) ?? null;\n    const { year, isSeries } = extractMetadataInfo(candidate as HTMLElement);\n    const normalizedTitle = normalizeTitle(title);\n    if (!normalizedTitle) continue;\n\n    const extracted: ExtractedTitleInfo = {\n      rawTitle: title,\n      normalizedTitle,\n      year: year ?? null,\n      isSeries,\n      netflixId,\n      href\n    };\n\n    return {\n      jawboneEl: candidate as HTMLElement,\n      extracted,\n      rejectedCount: display.rejectedCount,\n      chosenTitleElement: display.chosen\n    };\n  }\n\n  return { jawboneEl: null, extracted: null };\n};\n\nexport const resolveTitleText = (\n  container?: Element | null,\n  fallback?: string\n): string | undefined => {\n  const primary = findPrimaryTitle(container);\n  if (primary) return primary;\n\n  const normalizedFallback = normalizeNetflixTitle(fallback);\n  if (normalizedFallback && !EPISODE_TITLE_PATTERN.test(normalizedFallback)) {\n    return normalizedFallback;\n  }\n\n  if (fallback) return normalizeNetflixTitle(fallback) ?? fallback;\n  return undefined;\n};\n\n\nconst findBestAnchorIn = (container: Element): HTMLAnchorElement | undefined => {\n  const anchors = Array.from(container.querySelectorAll<HTMLAnchorElement>(TITLE_ANCHOR_SELECTOR));\n  const visible = anchors.filter(isVisible);\n  if (visible.length > 0) return visible[0];\n  return anchors[0];\n};\n\nconst findExpandedContainers = (): Element[] => {\n  const selectors = CONTAINER_SELECTORS.join(\",\");\n  const nodes = Array.from(document.querySelectorAll(selectors));\n  const visible = nodes.filter(isVisible);\n  const maxWidth = window.innerWidth * 0.85;\n  const maxHeight = window.innerHeight * 0.6;\n  const filtered = visible.filter((el) => {\n    const rect = el.getBoundingClientRect();\n    if (rect.width === 0 || rect.height === 0) return false;\n    if (rect.width < 240 || rect.height < 180) return false;\n    if (rect.width > maxWidth || rect.height > maxHeight) return false;\n    return true;\n  });\n  if (filtered.length > 0) {\n    return filtered.sort((a, b) => {\n      const ra = a.getBoundingClientRect();\n      const rb = b.getBoundingClientRect();\n      return rb.width * rb.height - ra.width * ra.height;\n    });\n  }\n  return visible.length > 0 ? visible : nodes;\n};\n\nconst collectJawboneCandidates = (): Element[] => {\n  const candidates = findExpandedContainers();\n  if (candidates.length) return candidates;\n\n  const controls = Array.from(document.querySelectorAll(CONTROLS_SELECTORS.join(\",\")));\n  const maxWidth = window.innerWidth * 0.85;\n  const maxHeight = window.innerHeight * 0.6;\n  const roots = new Set<Element>();\n\n  controls.forEach((control) => {\n    let current: Element | null = control;\n    let depth = 0;\n    while (current && depth < 6) {\n      if (current instanceof HTMLElement) {\n        const rect = current.getBoundingClientRect();\n        if (\n          rect.width >= 240 &&\n          rect.height >= 180 &&\n          rect.width <= maxWidth &&\n          rect.height <= maxHeight\n        ) {\n          const preview = findPreviewElement(current);\n          if (preview) {\n            roots.add(current);\n            break;\n          }\n        }\n      }\n      current = current.parentElement;\n      depth += 1;\n    }\n  });\n\n  return Array.from(roots);\n};\n\nexport const detectActiveTitleContext = (): {\n  candidate: ActiveTitleCandidate | null;\n  container: Element | null;\n} => {\n  const containers = findExpandedContainers();\n\n  for (const container of containers) {\n    const anchor = findBestAnchorIn(container);\n    if (anchor) {\n      const candidate = extractFromAnchor(anchor, \"container-anchor\");\n      if (candidate.netflixTitleId || candidate.titleText) {\n        const titleText = candidate.titleText ?? extractTitleTextNear(container);\n        const resolvedTitle = resolveTitleText(container, titleText ?? candidate.titleText);\n        return {\n          candidate: {\n            ...candidate,\n            titleText: resolvedTitle,\n            year: parseYearFromText(resolvedTitle ?? titleText)\n          },\n          container\n        };\n      }\n    }\n\n    const titleText = extractTitleTextNear(container);\n    if (titleText) {\n      const resolvedTitle = resolveTitleText(container, titleText);\n      return {\n        candidate: {\n          titleText: resolvedTitle ?? titleText,\n          year: parseYearFromText(resolvedTitle ?? titleText),\n          source: \"container-text\"\n        },\n        container\n      };\n    }\n  }\n\n  const fallbackAnchor = Array.from(\n    document.querySelectorAll<HTMLAnchorElement>(TITLE_ANCHOR_SELECTOR)\n  ).find(isVisible);\n  if (fallbackAnchor) {\n    const candidate = extractFromAnchor(fallbackAnchor, \"page-anchor\");\n    const resolvedTitle = resolveTitleText(\n      fallbackAnchor.closest(CONTAINER_SELECTORS.join(\",\")) ?? fallbackAnchor.parentElement,\n      candidate.titleText\n    );\n    return {\n      candidate: {\n        ...candidate,\n        titleText: resolvedTitle ?? candidate.titleText,\n        year: parseYearFromText(resolvedTitle ?? candidate.titleText)\n      },\n      container: fallbackAnchor.closest(CONTAINER_SELECTORS.join(\",\")) ?? fallbackAnchor.parentElement\n    };\n  }\n\n  return { candidate: null, container: null };\n};\n\n// Intentionally no default export.\n","import type { OverlayData } from \"../../../shared/types\";\n\nconst TOP_SECTION_ID = \"nxlb-top-section\";\n\nconst buildTopSection = (): HTMLDivElement => {\n  const host = document.createElement(\"div\");\n  host.id = TOP_SECTION_ID;\n  host.style.display = \"block\";\n  host.style.width = \"100%\";\n  host.style.pointerEvents = \"none\";\n\n  const shadow = host.attachShadow({ mode: \"open\" });\n  const style = document.createElement(\"style\");\n  style.textContent = `\n    :host {\n      all: initial;\n      font-family: \"Netflix Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n      pointer-events: none;\n      display: block;\n      width: 100%;\n      box-sizing: border-box;\n      opacity: 0;\n      transform: translateY(-8px);\n      transition: opacity 180ms cubic-bezier(0.2, 0, 0, 1),\n        transform 180ms cubic-bezier(0.2, 0, 0, 1);\n      will-change: opacity, transform;\n    }\n    :host(.nxl-visible) {\n      opacity: 1;\n      transform: translateY(0);\n    }\n    .nxl-top-section {\n      background: rgba(0, 0, 0, 0.82);\n      color: #f5f5f5;\n      padding: 16px 20px;\n      border-top-left-radius: 12px;\n      border-top-right-radius: 12px;\n      border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n      display: grid;\n      gap: 8px;\n      box-sizing: border-box;\n    }\n    .nxl-header {\n      display: flex;\n      align-items: center;\n      justify-content: flex-end;\n      gap: 16px;\n    }\n    .nxl-branding {\n      display: inline-flex;\n      align-items: center;\n      gap: 8px;\n      font-size: 12px;\n      color: rgba(255, 255, 255, 0.85);\n      white-space: nowrap;\n      flex-shrink: 0;\n    }\n    .nxl-dots {\n      display: inline-flex;\n      gap: 4px;\n      align-items: center;\n    }\n    .nxl-dot {\n      width: 8px;\n      height: 8px;\n      border-radius: 999px;\n      display: inline-block;\n    }\n    .nxl-dot.green { background: #00c46a; }\n    .nxl-dot.orange { background: #f2b34c; }\n    .nxl-dot.blue { background: #4aa8ff; }\n    .nxl-body {\n      display: grid;\n      gap: 6px;\n      font-size: 15px;\n      color: rgba(255, 255, 255, 0.9);\n    }\n    .nxl-rating {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n    }\n    .nxl-star {\n      color: #e3b341;\n      font-size: 16px;\n    }\n    .nxl-match {\n      display: flex;\n      align-items: baseline;\n      gap: 8px;\n    }\n    .nxl-match-value {\n      color: #46d369;\n      font-weight: 700;\n      font-size: 20px;\n    }\n    .nxl-because {\n      color: rgba(255, 255, 255, 0.7);\n      font-size: 14px;\n    }\n    .nxl-badges {\n      display: flex;\n      gap: 8px;\n      flex-wrap: wrap;\n      font-size: 12px;\n      color: rgba(255, 255, 255, 0.85);\n    }\n    .nxl-badge {\n      display: inline-flex;\n      align-items: center;\n      gap: 6px;\n      padding: 4px 8px;\n      border-radius: 999px;\n      border: 1px solid rgba(255, 255, 255, 0.18);\n      background: rgba(255, 255, 255, 0.06);\n    }\n  `;\n\n  const section = document.createElement(\"div\");\n  section.className = \"nxl-top-section\";\n\n  const header = document.createElement(\"div\");\n  header.className = \"nxl-header\";\n\n  const branding = document.createElement(\"div\");\n  branding.className = \"nxl-branding\";\n  branding.innerHTML = `\n    Powered by\n    <span class=\"nxl-dots\">\n      <span class=\"nxl-dot green\"></span>\n      <span class=\"nxl-dot orange\"></span>\n      <span class=\"nxl-dot blue\"></span>\n    </span>\n    Letterboxd\n  `;\n\n  header.appendChild(branding);\n\n  const body = document.createElement(\"div\");\n  body.className = \"nxl-body\";\n\n  const communityRating = document.createElement(\"div\");\n  communityRating.className = \"nxl-rating\";\n  communityRating.dataset.field = \"communityRating\";\n  communityRating.textContent = \"Community rating: —\";\n\n  const match = document.createElement(\"div\");\n  match.className = \"nxl-match\";\n  match.dataset.field = \"match\";\n  match.textContent = \"Your match: —\";\n\n  const because = document.createElement(\"div\");\n  because.className = \"nxl-because\";\n  because.dataset.field = \"because\";\n  because.textContent = \"Because you like: —\";\n\n  const badges = document.createElement(\"div\");\n  badges.className = \"nxl-badges\";\n  badges.dataset.field = \"badges\";\n\n  body.appendChild(communityRating);\n  body.appendChild(match);\n  body.appendChild(because);\n  body.appendChild(badges);\n\n  section.appendChild(header);\n  section.appendChild(body);\n\n  shadow.appendChild(style);\n  shadow.appendChild(section);\n\n  return host;\n};\n\nconst formatRatingCount = (value: number | null | undefined) => {\n  if (value === undefined || value === null) return \"\";\n  if (value >= 1_000_000) return `${(value / 1_000_000).toFixed(1)}M`;\n  if (value >= 1_000) return `${(value / 1_000).toFixed(1)}K`;\n  return `${value}`;\n};\n\nconst renderStars = (rating: number) => {\n  const clamped = Math.max(0, Math.min(5, rating));\n  const full = Math.floor(clamped);\n  const half = clamped % 1 >= 0.5;\n  return \"★\".repeat(full) + (half ? \"½\" : \"\");\n};\n\nconst applyTopSectionData = (host: HTMLDivElement, data: OverlayData) => {\n  const tmdbVoteAverage = data.tmdb?.voteAverage ?? null;\n  const tmdbVoteCount = data.tmdb?.voteCount ?? null;\n  const letterboxd = data.letterboxd;\n  const communityEl = host.shadowRoot?.querySelector(\n    \"[data-field='communityRating']\"\n  ) as HTMLDivElement | null;\n  if (communityEl) {\n    if (tmdbVoteAverage !== null && tmdbVoteAverage !== undefined) {\n      const count = formatRatingCount(tmdbVoteCount);\n      const ratingOutOfFive = tmdbVoteAverage / 2;\n      communityEl.innerHTML = `\n        Community rating:\n        <span class=\"nxl-star\">★</span>\n        ${ratingOutOfFive.toFixed(1)}${\n        count ? ` <span class=\"nxl-meta\">${count} ratings</span>` : \"\"\n      }\n      `;\n    } else {\n      communityEl.textContent = \"Community rating: —\";\n    }\n  }\n\n  const matchEl = host.shadowRoot?.querySelector(\"[data-field='match']\") as\n    | HTMLDivElement\n    | null;\n  if (matchEl) {\n    if (letterboxd?.matchPercent !== null && letterboxd?.matchPercent !== undefined) {\n      matchEl.innerHTML = `Your match: <span class=\"nxl-match-value\">${letterboxd.matchPercent}%</span>`;\n    } else {\n      matchEl.textContent = \"Your match: —\";\n    }\n  }\n\n  const becauseEl = host.shadowRoot?.querySelector(\"[data-field='because']\") as\n    | HTMLDivElement\n    | null;\n  if (becauseEl) {\n    const list = letterboxd?.becauseYouLike ?? [];\n    becauseEl.textContent =\n      list.length > 0 ? `Because you like: ${list.join(\", \")}` : \"Because you like: —\";\n  }\n\n  const badgesEl = host.shadowRoot?.querySelector(\"[data-field='badges']\") as\n    | HTMLDivElement\n    | null;\n  if (badgesEl) {\n    badgesEl.innerHTML = \"\";\n    if (letterboxd?.inWatchlist) {\n      const badge = document.createElement(\"span\");\n      badge.className = \"nxl-badge\";\n      badge.textContent = \"On your watchlist\";\n      badgesEl.appendChild(badge);\n    }\n    if (letterboxd?.userRating !== null && letterboxd?.userRating !== undefined) {\n      const badge = document.createElement(\"span\");\n      badge.className = \"nxl-badge\";\n      badge.textContent = `You rated ${renderStars(letterboxd.userRating)}`;\n      badgesEl.appendChild(badge);\n    }\n    if (!letterboxd?.inWatchlist && letterboxd?.userRating === undefined) {\n      const badge = document.createElement(\"span\");\n      badge.className = \"nxl-badge\";\n      badge.textContent = \"Letterboxd: —\";\n      badgesEl.appendChild(badge);\n    }\n  }\n};\n\nexport const createOverlayManager = () => {\n  let currentRoot: HTMLElement | null = null;\n  let host: HTMLDivElement | null = null;\n  let lastData: OverlayData | null = null;\n\n  const ensureHost = () => {\n    if (!host) host = buildTopSection();\n  };\n\n  const mount = (expandedRoot: HTMLElement) => {\n    ensureHost();\n    if (!host) return;\n    if (currentRoot !== expandedRoot) {\n      host.remove();\n      expandedRoot.insertBefore(host, expandedRoot.firstChild);\n      currentRoot = expandedRoot;\n      requestAnimationFrame(() => {\n        host?.classList.add(\"nxl-visible\");\n      });\n    }\n  };\n\n  const update = (data: OverlayData) => {\n    lastData = data;\n    if (host) applyTopSectionData(host, data);\n  };\n\n  const unmount = () => {\n    if (host) host.remove();\n    currentRoot = null;\n  };\n\n  const renderLast = () => {\n    if (host && lastData) applyTopSectionData(host, lastData);\n  };\n\n  return {\n    mount,\n    update,\n    unmount,\n    renderLast,\n    getLastData: () => lastData,\n    getCurrentRoot: () => currentRoot,\n    isMounted: () => Boolean(host && host.isConnected)\n  };\n};\n","import { log } from \"../../../shared/logger\";\n\nconst BADGE_ID = \"nxlb-status-badge\";\n\nconst buildBadgeHost = () => {\n  const host = document.createElement(\"div\");\n  host.id = BADGE_ID;\n  host.style.position = \"fixed\";\n  host.style.bottom = \"16px\";\n  host.style.right = \"16px\";\n  host.style.zIndex = \"2147483647\";\n  host.style.pointerEvents = \"none\";\n\n  const shadow = host.attachShadow({ mode: \"open\" });\n  const style = document.createElement(\"style\");\n  style.textContent = `\n    :host {\n      all: initial;\n      font-family: \"Netflix Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n    }\n    .badge {\n      display: inline-flex;\n      align-items: center;\n      gap: 8px;\n      background: rgba(0, 0, 0, 0.8);\n      border: 1px solid rgba(255, 255, 255, 0.12);\n      border-radius: 999px;\n      padding: 8px 12px;\n      color: #f5f5f5;\n      font-size: 12px;\n      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.35);\n      pointer-events: auto;\n      position: relative;\n    }\n    .dots {\n      display: inline-flex;\n      gap: 4px;\n      align-items: center;\n    }\n    .dot {\n      width: 8px;\n      height: 8px;\n      border-radius: 50%;\n      display: inline-block;\n    }\n    .dot.orange { background: #f2b34c; }\n    .dot.green { background: #00c46a; }\n    .dot.blue { background: #4aa8ff; }\n    .status {\n      width: 6px;\n      height: 6px;\n      border-radius: 50%;\n      background: #46d369;\n      box-shadow: 0 0 6px rgba(70, 211, 105, 0.6);\n    }\n    .tooltip {\n      position: absolute;\n      bottom: calc(100% + 8px);\n      right: 0;\n      background: rgba(0, 0, 0, 0.9);\n      color: #f5f5f5;\n      font-size: 11px;\n      padding: 6px 8px;\n      border-radius: 8px;\n      opacity: 0;\n      transform: translateY(4px);\n      transition: opacity 120ms ease, transform 120ms ease;\n      white-space: nowrap;\n      pointer-events: none;\n    }\n    .badge:hover .tooltip {\n      opacity: 1;\n      transform: translateY(0);\n    }\n  `;\n\n  const badge = document.createElement(\"div\");\n  badge.className = \"badge\";\n  badge.innerHTML = `\n    <span class=\"dots\">\n      <span class=\"dot orange\"></span>\n      <span class=\"dot green\"></span>\n      <span class=\"dot blue\"></span>\n    </span>\n    <span>Letterboxd</span>\n    <span class=\"status\" aria-hidden=\"true\"></span>\n    <span class=\"tooltip\">Netflix × Letterboxd overlay enabled</span>\n  `;\n\n  shadow.appendChild(style);\n  shadow.appendChild(badge);\n  return host;\n};\n\nexport const setBadgeVisible = (enabled: boolean) => {\n  const existing = document.getElementById(BADGE_ID);\n  if (!enabled) {\n    if (existing) {\n      existing.remove();\n      log(\"OVERLAY_BADGE_REMOVED\");\n    }\n    return;\n  }\n\n  if (existing) return;\n\n  const host = buildBadgeHost();\n  document.documentElement.appendChild(host);\n  log(\"OVERLAY_BADGE_MOUNTED\");\n};\n","import { log, DEBUG } from \"../../shared/logger\";\nimport { STORAGE_KEYS } from \"../../shared/constants\";\nimport { getStorage, setStorage } from \"../../shared/storage\";\nimport { buildLetterboxdKey } from \"../../shared/normalize\";\nimport type {\n  LetterboxdIndexUpdatedAckMessage,\n  LetterboxdIndexUpdatedMessage,\n  ExtractedTitleInfo,\n  OverlayData,\n  OverlayDataResolvedMessage,\n  ResolveOverlayDataMessage\n} from \"../../shared/types\";\nimport {\n  findActiveJawbone\n} from \"./selectors\";\nimport { createOverlayManager } from \"../ui/overlay\";\nimport { setBadgeVisible } from \"../ui/badge\";\n\nconst TOGGLE_COMBO = {\n  ctrlKey: true,\n  shiftKey: true,\n  key: \"l\"\n};\nconst OBSERVER_DEBOUNCE_MS = 250;\nconst WATCHDOG_INTERVAL_MS = 2000;\nconst HERO_WIDTH_THRESHOLD = 0.85;\nconst HERO_HEIGHT_THRESHOLD = 0.6;\n\nconst overlayManager = createOverlayManager();\n\nlet overlayEnabled = true;\nlet lastActiveKey = \"\";\nlet lastContainer: Element | null = null;\nlet debounceTimer: number | undefined;\nlet watchdogTimer: number | undefined;\nlet lastRequestId = \"\";\nlet lastOutlined: HTMLElement | null = null;\nlet playbackActive = false;\nlet lastResolvedPayload: OverlayData | null = null;\n\ntype NxlWindow = Window & {\n  __nxlBooted?: boolean;\n  __nxlDebug?: {\n    getLbIndex: () => Promise<Record<string, unknown>>;\n    lastOverlayData: () => OverlayData | null;\n    forceResolve: () => void;\n  };\n};\n\nconst getNxlWindow = () => window as NxlWindow;\n\nconst describeElement = (el: Element | null) => {\n  if (!el) return \"none\";\n  const parts = [el.tagName.toLowerCase()];\n  const className = (el as HTMLElement).className;\n  if (className) {\n    parts.push(\n      \".\" +\n        className\n          .toString()\n          .split(/\\s+/)\n          .filter(Boolean)\n          .slice(0, 3)\n          .join(\".\")\n    );\n  }\n  const dataUia = (el as HTMLElement).getAttribute?.(\"data-uia\");\n  if (dataUia) parts.push(`[data-uia=\"${dataUia}\"]`);\n  return parts.join(\"\");\n};\n\nconst isHeroSized = (el: Element | null) => {\n  if (!el) return false;\n  const rect = el.getBoundingClientRect();\n  if (rect.width === 0 || rect.height === 0) return false;\n  return (\n    rect.width > window.innerWidth * HERO_WIDTH_THRESHOLD ||\n    rect.height > window.innerHeight * HERO_HEIGHT_THRESHOLD\n  );\n};\n\nconst updateDebugOutline = (container: HTMLElement | null) => {\n  if (lastOutlined && lastOutlined !== container) {\n    lastOutlined.style.outline = \"\";\n    lastOutlined.style.outlineOffset = \"\";\n    lastOutlined = null;\n  }\n  if (container && DEBUG) {\n    container.style.outline = \"1px solid rgba(255, 80, 80, 0.85)\";\n    container.style.outlineOffset = \"-1px\";\n    lastOutlined = container;\n  }\n};\n\nconst isPlaybackRoute = () => window.location.pathname.includes(\"/watch/\");\n\nconst isPlayingMainVideo = () => {\n  const videos = Array.from(document.querySelectorAll(\"video\"));\n  return videos.some((video) => {\n    if (video.paused || video.ended) return false;\n    const rect = video.getBoundingClientRect();\n    if (rect.width === 0 || rect.height === 0) return false;\n    const widthRatio = rect.width / window.innerWidth;\n    const heightRatio = rect.height / window.innerHeight;\n    return widthRatio > 0.85 || heightRatio > 0.6;\n  });\n};\n\nconst hasPlayerContainer = () => {\n  return Boolean(\n    document.querySelector(\n      \"[data-uia*='video-player'], [class*='VideoPlayer'], [class*='watch-video'], [data-uia*='player']\"\n    )\n  );\n};\n\nconst detectPlaybackActive = () => {\n  if (isPlaybackRoute()) return true;\n  if (isPlayingMainVideo()) return true;\n  if (hasPlayerContainer() && isPlayingMainVideo()) return true;\n  return false;\n};\n\nconst updatePlaybackState = () => {\n  const next = detectPlaybackActive();\n  if (next === playbackActive) return;\n  playbackActive = next;\n\n  if (playbackActive) {\n    setBadgeVisible(false);\n    log(\"BADGE_HIDDEN_PLAYBACK\");\n    overlayManager.unmount();\n  } else {\n    if (overlayEnabled) {\n      setBadgeVisible(true);\n      log(\"BADGE_SHOWN\");\n      log(\"BROWSE_MODE_DETECTED\");\n    }\n  }\n};\n\nconst setBadgeForState = () => {\n  if (!overlayEnabled) {\n    setBadgeVisible(false);\n    return;\n  }\n  if (!playbackActive) {\n    setBadgeVisible(true);\n    log(\"BADGE_SHOWN\");\n  }\n};\n\nconst serializeCandidateKey = (info: ExtractedTitleInfo) => {\n  return [\n    info.normalizedTitle ?? \"\",\n    info.year ?? \"\",\n    info.netflixId ?? \"\",\n    info.href ?? \"\"\n  ].join(\"|\");\n};\n\nconst buildEmptyOverlayData = (title: string, year?: number): OverlayData => ({\n  title,\n  year: year ?? null,\n  tmdb: {\n    id: null,\n    voteAverage: null,\n    voteCount: null\n  },\n  letterboxd: {\n    inWatchlist: false,\n    userRating: null,\n    matchPercent: null,\n    becauseYouLike: []\n  }\n});\n\nconst attemptResolve = (reason: string) => {\n  if (!overlayEnabled) return;\n  updatePlaybackState();\n  if (playbackActive) return;\n\n  if (DEBUG) log(\"OVERLAY_MOUNT_ATTEMPT\", { reason });\n  const jawbone = findActiveJawbone();\n  const root = jawbone.jawboneEl;\n  const extracted = jawbone.extracted;\n\n  if (!root || !extracted) {\n    if (DEBUG) log(\"OVERLAY_MOUNT_FAILED\", { reason: \"no-jawbone\" });\n    overlayManager.unmount();\n    updateDebugOutline(null);\n    return;\n  }\n\n  if (isHeroSized(root)) {\n    if (DEBUG) log(\"OVERLAY_MOUNT_FAILED\", { reason: \"hero-sized\" });\n    overlayManager.unmount();\n    updateDebugOutline(null);\n    return;\n  }\n\n  if (DEBUG) {\n    log(\"ACTIVE_JAWBONE_FOUND\", {\n      rawTitle: extracted.rawTitle,\n      netflixId: extracted.netflixId,\n      year: extracted.year,\n      isSeries: extracted.isSeries,\n      rejectedTitleCandidates: jawbone.rejectedCount,\n      chosenTitleElement: jawbone.chosenTitleElement\n        ? jawbone.chosenTitleElement.outerHTML.slice(0, 200)\n        : undefined\n    });\n    log(\"EXTRACTED_TITLE_INFO\", extracted);\n  }\n\n  const key = serializeCandidateKey(extracted);\n  if (key === lastActiveKey && root === lastContainer) {\n    if (DEBUG) log(\"OVERLAY_MOUNT_SUCCESS\", { reused: true });\n    return;\n  }\n\n  lastActiveKey = key;\n  lastContainer = root;\n  updateDebugOutline(root);\n\n  overlayManager.mount(root);\n  overlayManager.update(buildEmptyOverlayData(extracted.rawTitle, extracted.year ?? undefined));\n\n  const requestId = `req_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;\n  lastRequestId = requestId;\n  const message: ResolveOverlayDataMessage = {\n    type: \"RESOLVE_OVERLAY_DATA\",\n    requestId,\n    payload: extracted\n  };\n\n  log(\"OVERLAY_REQUEST\", {\n    titleText: extracted.rawTitle,\n    normalizedTitle: extracted.normalizedTitle,\n    href: extracted.href,\n    year: extracted.year\n  });\n\n  chrome.runtime\n    .sendMessage(message)\n    .then((response: OverlayDataResolvedMessage) => {\n      if (response?.type !== \"OVERLAY_DATA_RESOLVED\") return;\n      if (response.requestId !== lastRequestId) return;\n      lastResolvedPayload = response.payload;\n      log(\"OVERLAY_RESPONSE\", {\n        requestId,\n        tmdb: response.payload.tmdb,\n        letterboxd: {\n          inWatchlist: response.payload.letterboxd?.inWatchlist ?? false,\n          userRating: response.payload.letterboxd?.userRating ?? null,\n          matchPercent: response.payload.letterboxd?.matchPercent ?? null,\n          becauseYouLikeCount: response.payload.letterboxd?.becauseYouLike?.length ?? 0\n        }\n      });\n\n      overlayManager.update(response.payload);\n\n      if (DEBUG) {\n        const lb = response.payload.letterboxd;\n        if (!lb || (!lb.inWatchlist && lb.userRating === null)) {\n          const keyForLookup = buildLetterboxdKey(extracted.rawTitle, extracted.year ?? undefined);\n          chrome.storage.local.get([STORAGE_KEYS.LETTERBOXD_INDEX]).then((data) => {\n            if (!data[STORAGE_KEYS.LETTERBOXD_INDEX]) {\n              log(\"LB_MATCH_NOT_FOUND\", { reason: \"no-index\", key: keyForLookup });\n            } else if (!extracted.year) {\n              log(\"LB_MATCH_NOT_FOUND\", { reason: \"missing-year\", key: keyForLookup });\n            } else {\n              log(\"LB_MATCH_NOT_FOUND\", { reason: \"no-key\", key: keyForLookup });\n            }\n          });\n        }\n      }\n    })\n    .catch((err) => {\n      log(\"Title resolve failed\", { requestId, err });\n    });\n};\n\nconst scheduleResolve = (reason: string) => {\n  if (debounceTimer) window.clearTimeout(debounceTimer);\n  debounceTimer = window.setTimeout(() => {\n    attemptResolve(reason);\n  }, OBSERVER_DEBOUNCE_MS);\n};\n\nconst observeTitleChanges = () => {\n  const observer = new MutationObserver(() => {\n    try {\n      scheduleResolve(\"mutation\");\n    } catch (error) {\n      log(\"Mutation observer failed\", { error });\n    }\n  });\n  observer.observe(document.body, {\n    childList: true,\n    subtree: true,\n    attributes: true,\n    attributeFilter: [\"class\", \"style\", \"aria-expanded\", \"aria-hidden\"]\n  });\n\n  document.addEventListener(\n    \"pointerover\",\n    () => {\n      try {\n        scheduleResolve(\"pointer\");\n      } catch (error) {\n        log(\"Pointer observer failed\", { error });\n      }\n    },\n    true\n  );\n  document.addEventListener(\n    \"focusin\",\n    () => {\n      try {\n        scheduleResolve(\"focus\");\n      } catch (error) {\n        log(\"Focus observer failed\", { error });\n      }\n    },\n    true\n  );\n\n  if (watchdogTimer) window.clearInterval(watchdogTimer);\n  watchdogTimer = window.setInterval(() => {\n    if (!overlayEnabled) return;\n    updatePlaybackState();\n    if (playbackActive) return;\n    if (!overlayManager.isMounted()) {\n      attemptResolve(\"watchdog\");\n    }\n  }, WATCHDOG_INTERVAL_MS);\n\n  scheduleResolve(\"init\");\n};\n\nconst toggleOverlay = async () => {\n  const state = await getStorage();\n  const next = !(state[STORAGE_KEYS.OVERLAY_ENABLED] ?? true);\n  await setStorage({ [STORAGE_KEYS.OVERLAY_ENABLED]: next });\n  overlayEnabled = next;\n  if (!next) {\n    overlayManager.unmount();\n    setBadgeVisible(false);\n  } else {\n    setBadgeForState();\n    scheduleResolve(\"toggle\");\n  }\n  log(\"Overlay toggled\", { enabled: next });\n};\n\nconst handleKeydown = (event: KeyboardEvent) => {\n  if (\n    event.ctrlKey === TOGGLE_COMBO.ctrlKey &&\n    event.shiftKey === TOGGLE_COMBO.shiftKey &&\n    event.key.toLowerCase() === TOGGLE_COMBO.key\n  ) {\n    event.preventDefault();\n    toggleOverlay().catch((err) => log(\"Toggle failed\", err));\n  }\n};\n\nconst bindRuntimeMessages = () => {\n  chrome.runtime.onMessage.addListener(\n    (message: LetterboxdIndexUpdatedAckMessage | LetterboxdIndexUpdatedMessage) => {\n    if (message?.type === \"LB_INDEX_UPDATED\") {\n      log(\"LB_INDEX_UPDATED\");\n      scheduleResolve(\"lb-index-updated\");\n      return;\n    }\n    if (message?.type === \"LB_INDEX_UPDATED_ACK\") {\n      log(\"LB_INDEX_UPDATED_ACK\", message.payload);\n      scheduleResolve(\"lb-index-updated\");\n    }\n  });\n};\n\nconst setDebugHook = () => {\n  const win = getNxlWindow();\n  win.__nxlDebug = {\n    getLbIndex: async () => chrome.storage.local.get(STORAGE_KEYS.LETTERBOXD_INDEX),\n    lastOverlayData: () => lastResolvedPayload,\n    forceResolve: () => attemptResolve(\"force\")\n  };\n};\n\nexport const initNetflixObserver = async () => {\n  const win = getNxlWindow();\n  if (win.__nxlBooted) return;\n  win.__nxlBooted = true;\n\n  const state = await getStorage();\n  overlayEnabled = state[STORAGE_KEYS.OVERLAY_ENABLED] ?? true;\n\n  updatePlaybackState();\n  if (overlayEnabled && !playbackActive) {\n    setBadgeVisible(true);\n    log(\"BADGE_SHOWN\");\n    log(\"BROWSE_MODE_DETECTED\");\n  }\n\n  observeTitleChanges();\n  bindRuntimeMessages();\n  setDebugHook();\n  window.addEventListener(\"keydown\", handleKeydown);\n};\n","import { log } from \"../shared/logger\";\nimport { initNetflixObserver } from \"./netflix/observer\";\n\nconst init = async () => {\n  await initNetflixObserver();\n};\n\nif (document.readyState === \"loading\") {\n  document.addEventListener(\n    \"DOMContentLoaded\",\n    () => {\n      init().catch((err) => log(\"Init failed\", err));\n    },\n    { once: true }\n  );\n} else {\n  init().catch((err) => log(\"Init failed\", err));\n}\n"],"names":["STORAGE_KEYS","log","args","normalizeTitle","title","makeKey","year","normalized","suffix","buildLetterboxdKey","getStorage","setStorage","state","CONTAINER_SELECTORS","TITLE_TEXT_SELECTORS","PREVIEW_SELECTORS","CONTROLS_SELECTORS","EPISODE_TITLE_PATTERN","EPISODE_TIME_PATTERN","METADATA_TEXT_PATTERN","ACTION_TEXT_PATTERN","CONTEXT_TEXT_PATTERN","METADATA_SELECTORS","GENRE_SELECTORS","METADATA_CONTAINER_SELECTORS","HEADER_CONTAINER_SELECTORS","TITLE_LIKE_SELECTORS","NAV_BANNED_PATTERN","isVisible","el","rect","style","normalizeText","value","text","parseTitleIdFromHref","href","match","parseYearFromText","normalizeNetflixTitle","raw","inner","extractTitleTextNear","container","selector","getRawTitleText","findPreviewElement","candidates","best","current","bestRect","currentRect","bestArea","findControlsRow","root","scored","buttons","score","entry","a","b","_a","hasMetadataSection","selectors","node","isInMetadataRegion","isInHeaderRegion","isBannedTitleText","isInProgressRegion","controlsTop","isInControlsRegion","controls","extractDisplayTitle","expandedRoot","rootRect","rejectedCount","episodeNodes","fontSize","fontWeightRaw","fontWeight","dx","dy","dist","regionPenalty","episodeNode","depth","siblingCandidates","sibling","anchor","heading","directText","nearby","extractMetadataInfo","texts","next","nextText","combined","hasSeasons","hasRuntime","isSeries","extractTitleFromAnchor","_b","candidate","getBestTitleAnchor","previewEl","visibleAnchors","previewRect","area","findActiveJawbone","collectJawboneCandidates","maxWidth","maxHeight","preview","metadata","display","anchorTitle","fallbackTitle","netflixId","normalizedTitle","findExpandedContainers","nodes","visible","filtered","ra","rb","roots","control","TOP_SECTION_ID","buildTopSection","host","shadow","section","header","branding","body","communityRating","because","badges","formatRatingCount","renderStars","rating","clamped","full","half","applyTopSectionData","data","tmdbVoteAverage","tmdbVoteCount","letterboxd","communityEl","_c","count","ratingOutOfFive","matchEl","_d","becauseEl","_e","list","badgesEl","_f","badge","createOverlayManager","currentRoot","lastData","ensureHost","BADGE_ID","buildBadgeHost","setBadgeVisible","enabled","existing","TOGGLE_COMBO","OBSERVER_DEBOUNCE_MS","WATCHDOG_INTERVAL_MS","HERO_WIDTH_THRESHOLD","HERO_HEIGHT_THRESHOLD","overlayManager","overlayEnabled","lastActiveKey","lastContainer","debounceTimer","watchdogTimer","lastRequestId","lastOutlined","playbackActive","lastResolvedPayload","getNxlWindow","isHeroSized","updateDebugOutline","isPlaybackRoute","isPlayingMainVideo","video","widthRatio","heightRatio","hasPlayerContainer","detectPlaybackActive","updatePlaybackState","setBadgeForState","serializeCandidateKey","info","buildEmptyOverlayData","attemptResolve","reason","jawbone","extracted","key","requestId","message","response","lb","keyForLookup","err","scheduleResolve","observeTitleChanges","error","toggleOverlay","handleKeydown","event","bindRuntimeMessages","setDebugHook","win","initNetflixObserver","init"],"mappings":"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"}